(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{471:function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},476:function(n,e,t){t(471)(t(737))},478:function(n,e,t){t(471)(t(738))},485:function(n,e,t){t(471)(t(765))},488:function(n,e,t){t(471)(t(739))},505:function(n,e,t){t(471)(t(762))},521:function(n,e,t){t(471)(t(764))},543:function(n,e,t){n.exports=t(735)},544:function(n,e){function t(n,e,t,r,i,a,o){try{var s=n[a](o),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,i)}n.exports=function(n){return function(){var e=this,r=arguments;return new Promise((function(i,a){var o=n.apply(e,r);function s(n){t(o,i,a,s,l,"next",n)}function l(n){t(o,i,a,s,l,"throw",n)}s(void 0)}))}}},547:function(n,e,t){t(471)(t(763))},550:function(n,e,t){t(471)(t(784))},735:function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",o=r.toStringTag||"@@toStringTag";function s(n,e,t,r){var i=e&&e.prototype instanceof d?e:d,a=Object.create(i.prototype),o=new w(r||[]);return a._invoke=function(n,e,t){var r="suspendedStart";return function(i,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw a;return T()}for(t.method=i,t.arg=a;;){var o=t.delegate;if(o){var s=v(o,t);if(s){if(s===u)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var d=l(n,e,t);if("normal"===d.type){if(r=t.done?"completed":"suspendedYield",d.arg===u)continue;return{value:d.arg,done:t.done}}"throw"===d.type&&(r="completed",t.method="throw",t.arg=d.arg)}}}(n,t,o),a}function l(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var u={};function d(){}function p(){}function c(){}var m={};m[i]=function(){return this};var f=Object.getPrototypeOf,h=f&&f(f(k([])));h&&h!==e&&t.call(h,i)&&(m=h);var y=c.prototype=d.prototype=Object.create(m);function _(n){["next","throw","return"].forEach((function(e){n[e]=function(n){return this._invoke(e,n)}}))}function g(n,e){var r;this._invoke=function(i,a){function o(){return new e((function(r,o){!function r(i,a,o,s){var u=l(n[i],n,a);if("throw"!==u.type){var d=u.arg,p=d.value;return p&&"object"==typeof p&&t.call(p,"__await")?e.resolve(p.__await).then((function(n){r("next",n,o,s)}),(function(n){r("throw",n,o,s)})):e.resolve(p).then((function(n){d.value=n,o(d)}),(function(n){return r("throw",n,o,s)}))}s(u.arg)}(i,a,r,o)}))}return r=r?r.then(o,o):o()}}function v(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,v(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var r=l(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,u;var i=r.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function b(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function j(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function w(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(b,this),this.reset(!0)}function k(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:T}}function T(){return{value:void 0,done:!0}}return p.prototype=y.constructor=c,c.constructor=p,c[o]=p.displayName="GeneratorFunction",n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,c):(n.__proto__=c,o in n||(n[o]="GeneratorFunction")),n.prototype=Object.create(y),n},n.awrap=function(n){return{__await:n}},_(g.prototype),g.prototype[a]=function(){return this},n.AsyncIterator=g,n.async=function(e,t,r,i,a){void 0===a&&(a=Promise);var o=new g(s(e,t,r,i),a);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},_(y),y[o]="Generator",y[i]=function(){return this},y.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=k,w.prototype={constructor:w,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(j),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],o=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=t.call(a,"catchLoc"),l=t.call(a,"finallyLoc");if(s&&l){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var a=i;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=n,o.arg=e,a?(this.method="next",this.next=a.finallyLoc,u):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),j(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var i=r.arg;j(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:k(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}(n.exports);try{regeneratorRuntime=r}catch(n){Function("r","regeneratorRuntime = r")(r)}},737:function(n,e){n.exports="/**\n * jspsych.js\n * Josh de Leeuw\n *\n * documentation: docs.jspsych.org\n *\n **/\nwindow.jsPsych = (function() {\n\n  var core = {};\n\n  //\n  // private variables\n  //\n\n  // options\n  var opts = {};\n  // experiment timeline\n  var timeline;\n  // flow control\n  var global_trial_index = 0;\n  var current_trial = {};\n  var current_trial_finished = false;\n  // target DOM element\n  var DOM_container;\n  var DOM_target;\n  // time that the experiment began\n  var exp_start_time;\n  // is the experiment paused?\n  var paused = false;\n  var waiting = false;\n  // done loading?\n  var loaded = false;\n  var loadfail = false;\n\n  // storing a single webaudio context to prevent problems with multiple inits\n  // of jsPsych\n  core.webaudio_context = null;\n  // temporary patch for Safari\n  if (typeof window !== 'undefined' && window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext')) {\n    window.AudioContext = webkitAudioContext;\n  }\n  // end patch\n  core.webaudio_context = (typeof window !== 'undefined' && typeof window.AudioContext !== 'undefined') ? new AudioContext() : null;\n\n  // enumerated variables for special parameter types\n  core.ALL_KEYS = 'allkeys';\n  core.NO_KEYS = 'none';\n\n  //\n  // public methods\n  //\n\n  core.init = function(options) {\n\n    if(typeof options.timeline === 'undefined'){\n      console.error('No timeline declared in jsPsych.init. Cannot start experiment.')\n    }\n\n    // reset variables\n    timeline = null;\n    global_trial_index = 0;\n    current_trial = {};\n    current_trial_finished = false;\n    paused = false;\n    waiting = false;\n    loaded = false;\n    loadfail = false;\n    jsPsych.data.reset();\n\n    var defaults = {\n      'display_element': undefined,\n      'on_finish': function(data) {\n        return undefined;\n      },\n      'on_trial_start': function(trial) {\n        return undefined;\n      },\n      'on_trial_finish': function() {\n        return undefined;\n      },\n      'on_data_update': function(data) {\n        return undefined;\n      },\n      'on_interaction_data_update': function(data){\n        return undefined;\n      },\n      'on_close': function(){\n        return undefined;\n      },\n      'preload_images': [],\n      'preload_audio': [],\n      'preload_video': [],\n      'use_webaudio': true,\n      'exclusions': {},\n      'show_progress_bar': false,\n      'message_progress_bar': 'Completion Progress',\n      'auto_update_progress_bar': true,\n      'auto_preload': true,\n      'show_preload_progress_bar': true,\n      'max_load_time': 60000,\n      'max_preload_attempts': 10,\n      'default_iti': 0,\n      'experiment_width': null\n    };\n\n    // override default options if user specifies an option\n    opts = Object.assign({}, defaults, options);\n\n    // set DOM element where jsPsych will render content\n    // if undefined, then jsPsych will use the <body> tag and the entire page\n    if(typeof opts.display_element == 'undefined'){\n      // check if there is a body element on the page\n      var body = document.querySelector('body');\n      if (body === null) {\n        document.documentElement.appendChild(document.createElement('body'));\n      }\n      // using the full page, so we need the HTML element to\n      // have 100% height, and body to be full width and height with\n      // no margin\n      document.querySelector('html').style.height = '100%';\n      document.querySelector('body').style.margin = '0px';\n      document.querySelector('body').style.height = '100%';\n      document.querySelector('body').style.width = '100%';\n      opts.display_element = document.querySelector('body');\n    } else {\n      // make sure that the display element exists on the page\n      var display;\n      if (opts.display_element instanceof Element) {\n        var display = opts.display_element;\n      } else {\n        var display = document.querySelector('#' + opts.display_element);\n      }\n      if(display === null) {\n        console.error('The display_element specified in jsPsych.init() does not exist in the DOM.');\n      } else {\n        opts.display_element = display;\n      }\n    }\n    opts.display_element.innerHTML = '<div class=\"jspsych-content-wrapper\"><div id=\"jspsych-content\"></div></div>';\n    DOM_container = opts.display_element;\n    DOM_target = document.querySelector('#jspsych-content');\n    \n\n    // add tabIndex attribute to scope event listeners\n    opts.display_element.tabIndex = 0;\n\n    // add CSS class to DOM_target\n    if(opts.display_element.className.indexOf('jspsych-display-element') == -1){\n      opts.display_element.className += ' jspsych-display-element';\n    }\n    DOM_target.className += 'jspsych-content';\n\n    // set experiment_width if not null\n    if(opts.experiment_width !== null){\n      DOM_target.style.width = opts.experiment_width + \"px\";\n    }\n\n    // create experiment timeline\n    timeline = new TimelineNode({\n      timeline: opts.timeline\n    });\n\n    // initialize audio context based on options and browser capabilities\n    jsPsych.pluginAPI.initAudio();\n\n    // below code resets event listeners that may have lingered from\n    // a previous incomplete experiment loaded in same DOM.\n    jsPsych.pluginAPI.reset(opts.display_element);\n    // create keyboard event listeners\n    jsPsych.pluginAPI.createKeyboardEventListeners(opts.display_element);\n    // create listeners for user browser interaction\n    jsPsych.data.createInteractionListeners();\n\n    // add event for closing window\n    window.addEventListener('beforeunload', opts.on_close);\n\n    // check exclusions before continuing\n    checkExclusions(opts.exclusions,\n      function(){\n        // success! user can continue...\n        // start experiment, with or without preloading\n        if(opts.auto_preload){\n          jsPsych.pluginAPI.autoPreload(timeline, startExperiment, opts.preload_images, opts.preload_audio, opts.preload_video, opts.show_preload_progress_bar);\n          if(opts.max_load_time > 0){\n            setTimeout(function(){\n              if(!loaded && !loadfail){\n                core.loadFail();\n              }\n            }, opts.max_load_time);\n          }\n        } else {\n          startExperiment();\n        }\n      },\n      function(){\n        // fail. incompatible user.\n\n      }\n    );\n  };\n\n  core.progress = function() {\n\n    var percent_complete = typeof timeline == 'undefined' ? 0 : timeline.percentComplete();\n\n    var obj = {\n      \"total_trials\": typeof timeline == 'undefined' ? undefined : timeline.length(),\n      \"current_trial_global\": global_trial_index,\n      \"percent_complete\": percent_complete\n    };\n\n    return obj;\n  };\n\n  core.startTime = function() {\n    return exp_start_time;\n  };\n\n  core.totalTime = function() {\n    if(typeof exp_start_time == 'undefined'){ return 0; }\n    return (new Date()).getTime() - exp_start_time.getTime();\n  };\n\n  core.getDisplayElement = function() {\n    return DOM_target;\n  };\n\n  core.getDisplayContainerElement = function(){\n    return DOM_container;\n  }\n\n  core.finishTrial = function(data) {\n\n    if(current_trial_finished){ return; }\n    current_trial_finished = true;\n\n    // write the data from the trial\n    data = typeof data == 'undefined' ? {} : data;\n    jsPsych.data.write(data);\n\n    // get back the data with all of the defaults in\n    var trial_data = jsPsych.data.get().filter({trial_index: global_trial_index});\n\n    // for trial-level callbacks, we just want to pass in a reference to the values\n    // of the DataCollection, for easy access and editing.\n    var trial_data_values = trial_data.values()[0];\n\n    // handle callback at plugin level\n    if (typeof current_trial.on_finish === 'function') {\n      current_trial.on_finish(trial_data_values);\n    }\n\n    // handle callback at whole-experiment level\n    opts.on_trial_finish(trial_data_values);\n\n    // after the above callbacks are complete, then the data should be finalized\n    // for this trial. call the on_data_update handler, passing in the same\n    // data object that just went through the trial's finish handlers.\n    opts.on_data_update(trial_data_values);\n\n    // wait for iti\n    if (typeof current_trial.post_trial_gap === null || typeof current_trial.post_trial_gap === 'undefined') {\n      if (opts.default_iti > 0) {\n        setTimeout(nextTrial, opts.default_iti);\n      } else {\n        nextTrial();\n      }\n    } else {\n      if (current_trial.post_trial_gap > 0) {\n        setTimeout(nextTrial, current_trial.post_trial_gap);\n      } else {\n        nextTrial();\n      }\n    }\n  }\n\n  core.endExperiment = function(end_message) {\n    timeline.end_message = end_message;\n    timeline.end();\n    jsPsych.pluginAPI.cancelAllKeyboardResponses();\n    jsPsych.pluginAPI.clearAllTimeouts();\n    core.finishTrial();\n  }\n\n  core.endCurrentTimeline = function() {\n    timeline.endActiveNode();\n  }\n\n  core.currentTrial = function() {\n    return current_trial;\n  };\n\n  core.initSettings = function() {\n    return opts;\n  };\n\n  core.currentTimelineNodeID = function() {\n    return timeline.activeID();\n  };\n\n  core.timelineVariable = function(varname, execute){\n    if(execute){\n      return timeline.timelineVariable(varname);\n    } else {\n      return function() { return timeline.timelineVariable(varname); }\n    }\n  }\n\n  core.addNodeToEndOfTimeline = function(new_timeline, preload_callback){\n    timeline.insert(new_timeline);\n    if(typeof preload_callback !== 'undefinded'){\n      if(opts.auto_preload){\n        jsPsych.pluginAPI.autoPreload(timeline, preload_callback);\n      } else {\n        preload_callback();\n      }\n    }\n  }\n\n  core.pauseExperiment = function(){\n    paused = true;\n  }\n\n  core.resumeExperiment = function(){\n    paused = false;\n    if(waiting){\n      waiting = false;\n      nextTrial();\n    }\n  }\n\n  core.loadFail = function(message){\n    message = message || '<p>The experiment failed to load.</p>';\n    loadfail = true;\n    DOM_target.innerHTML = message;\n  }\n\n  function TimelineNode(parameters, parent, relativeID) {\n\n    // a unique ID for this node, relative to the parent\n    var relative_id;\n\n    // store the parent for this node\n    var parent_node;\n\n    // parameters for the trial if the node contains a trial\n    var trial_parameters;\n\n    // parameters for nodes that contain timelines\n    var timeline_parameters;\n\n    // stores trial information on a node that contains a timeline\n    // used for adding new trials\n    var node_trial_data;\n\n    // track progress through the node\n    var progress = {\n      current_location: -1, // where on the timeline (which timelinenode)\n      current_variable_set: 0, // which set of variables to use from timeline_variables\n      current_repetition: 0, // how many times through the variable set on this run of the node\n      current_iteration: 0, // how many times this node has been revisited\n      done: false\n    }\n\n    // reference to self\n    var self = this;\n\n    // recursively get the next trial to run.\n    // if this node is a leaf (trial), then return the trial.\n    // otherwise, recursively find the next trial in the child timeline.\n    this.trial = function() {\n      if (typeof timeline_parameters == 'undefined') {\n        // returns a clone of the trial_parameters to\n        // protect functions.\n        return jsPsych.utils.deepCopy(trial_parameters);\n      } else {\n        if (progress.current_location >= timeline_parameters.timeline.length) {\n          return null;\n        } else {\n          return timeline_parameters.timeline[progress.current_location].trial();\n        }\n      }\n    }\n\n    this.markCurrentTrialComplete = function() {\n      if(typeof timeline_parameters == 'undefined'){\n        progress.done = true;\n      } else {\n        timeline_parameters.timeline[progress.current_location].markCurrentTrialComplete();\n      }\n    }\n\n    this.nextRepetiton = function() {\n      this.setTimelineVariablesOrder();\n      progress.current_location = -1;\n      progress.current_variable_set = 0;\n      progress.current_repetition++;\n      for (var i = 0; i < timeline_parameters.timeline.length; i++) {\n        timeline_parameters.timeline[i].reset();\n      }\n    }\n\n    // set the order for going through the timeline variables array\n    this.setTimelineVariablesOrder = function() {\n\n      // check to make sure this node has variables\n      if(typeof timeline_parameters === 'undefined' || typeof timeline_parameters.timeline_variables === 'undefined'){\n        return;\n      }\n\n      var order = [];\n      for(var i=0; i<timeline_parameters.timeline_variables.length; i++){\n        order.push(i);\n      }\n\n      if(typeof timeline_parameters.sample !== 'undefined'){\n        if(timeline_parameters.sample.type == 'custom'){\n          order = timeline_parameters.sample.fn(order);\n        } else if(timeline_parameters.sample.type == 'with-replacement'){\n          order = jsPsych.randomization.sampleWithReplacement(order, timeline_parameters.sample.size, timeline_parameters.sample.weights);\n        } else if(timeline_parameters.sample.type == 'without-replacement'){\n          order = jsPsych.randomization.sampleWithoutReplacement(order, timeline_parameters.sample.size);\n        } else if(timeline_parameters.sample.type == 'fixed-repetitions'){\n          order = jsPsych.randomization.repeat(order, timeline_parameters.sample.size, false);\n        } else if(timeline_parameters.sample.type == 'alternate-groups'){\n          order = jsPsych.randomization.shuffleAlternateGroups(timeline_parameters.sample.groups, timeline_parameters.sample.randomize_group_order);\n        } else {\n          console.error('Invalid type in timeline sample parameters. Valid options for type are \"custom\", \"with-replacement\", \"without-replacement\", \"fixed-repetitions\", and \"alternate-groups\"');\n        }\n      }\n\n      if(timeline_parameters.randomize_order) {\n        order = jsPsych.randomization.shuffle(order);\n      }\n\n      progress.order = order;\n    }\n\n    // next variable set\n    this.nextSet = function() {\n      progress.current_location = -1;\n      progress.current_variable_set++;\n      for (var i = 0; i < timeline_parameters.timeline.length; i++) {\n        timeline_parameters.timeline[i].reset();\n      }\n    }\n\n    // update the current trial node to be completed\n    // returns true if the node is complete after advance (all subnodes are also complete)\n    // returns false otherwise\n    this.advance = function() {\n\n      // first check to see if done\n      if (progress.done) {\n        return true;\n      }\n\n      // if node has not started yet (progress.current_location == -1),\n      // then try to start the node.\n      if (progress.current_location == -1) {\n        // check for conditonal function on nodes with timelines\n        if (typeof timeline_parameters != 'undefined') {\n          if (typeof timeline_parameters.conditional_function !== 'undefined') {\n            var conditional_result = timeline_parameters.conditional_function();\n            // if the conditional_function() returns false, then the timeline\n            // doesn't run and is marked as complete.\n            if (conditional_result == false) {\n              progress.done = true;\n              return true;\n            }\n            // if the conditonal_function() returns true, then the node can start\n            else {\n              progress.current_location = 0;\n            }\n          }\n          // if there is no conditional_function, then the node can start\n          else {\n            progress.current_location = 0;\n          }\n        }\n        // if the node does not have a timeline, then it can start\n        progress.current_location = 0;\n        // call advance again on this node now that it is pointing to a new location\n        return this.advance();\n      }\n\n      // if this node has a timeline, propogate down to the current trial.\n      if (typeof timeline_parameters !== 'undefined') {\n\n        var have_node_to_run = false;\n        // keep incrementing the location in the timeline until one of the nodes reached is incomplete\n        while (progress.current_location < timeline_parameters.timeline.length && have_node_to_run == false) {\n\n          // check to see if the node currently pointed at is done\n          var target_complete = timeline_parameters.timeline[progress.current_location].advance();\n          if (!target_complete) {\n            have_node_to_run = true;\n            return false;\n          } else {\n            progress.current_location++;\n          }\n\n        }\n\n        // if we've reached the end of the timeline (which, if the code is here, we have)\n        // there are a few steps to see what to do next...\n\n        // first, check the timeline_variables to see if we need to loop through again\n        // with a new set of variables\n        if (progress.current_variable_set < progress.order.length - 1) {\n          // reset the progress of the node to be with the new set\n          this.nextSet();\n          // then try to advance this node again.\n          return this.advance();\n        }\n\n        // if we're all done with the timeline_variables, then check to see if there are more repetitions\n        else if (progress.current_repetition < timeline_parameters.repetitions - 1) {\n          this.nextRepetiton();\n          return this.advance();\n        }\n\n        // if we're all done with the repetitions, check if there is a loop function.\n        else if (typeof timeline_parameters.loop_function !== 'undefined') {\n          if (timeline_parameters.loop_function(this.generatedData())) {\n            this.reset();\n            return parent_node.advance();\n          } else {\n            progress.done = true;\n            return true;\n          }\n        }\n\n        // no more loops on this timeline, we're done!\n        else {\n          progress.done = true;\n          return true;\n        }\n\n      }\n    }\n\n    // check the status of the done flag\n    this.isComplete = function() {\n      return progress.done;\n    }\n\n    // getter method for timeline variables\n    this.getTimelineVariableValue = function(variable_name){\n      if(typeof timeline_parameters == 'undefined'){\n        return undefined;\n      }\n      var v = timeline_parameters.timeline_variables[progress.order[progress.current_variable_set]][variable_name];\n      return v;\n    }\n\n    // recursive upward search for timeline variables\n    this.findTimelineVariable = function(variable_name){\n      var v = this.getTimelineVariableValue(variable_name);\n      if(typeof v == 'undefined'){\n        if(typeof parent_node !== 'undefined'){\n          return parent_node.findTimelineVariable(variable_name);\n        } else {\n          return undefined;\n        }\n      } else {\n        return v;\n      }\n    }\n\n    // recursive downward search for active trial to extract timeline variable\n    this.timelineVariable = function(variable_name){\n      if(typeof timeline_parameters == 'undefined'){\n        return this.findTimelineVariable(variable_name);\n      } else {\n        // if progress.current_location is -1, then the timeline variable is being evaluated\n        // in a function that runs prior to the trial starting, so we should treat that trial\n        // as being the active trial for purposes of finding the value of the timeline variable\n        var loc = Math.max(0, progress.current_location); \n        return timeline_parameters.timeline[loc].timelineVariable(variable_name);\n      }\n    }\n\n    // recursively get the number of **trials** contained in the timeline\n    // assuming that while loops execute exactly once and if conditionals\n    // always run\n    this.length = function() {\n      var length = 0;\n      if (typeof timeline_parameters !== 'undefined') {\n        for (var i = 0; i < timeline_parameters.timeline.length; i++) {\n          length += timeline_parameters.timeline[i].length();\n        }\n      } else {\n        return 1;\n      }\n      return length;\n    }\n\n    // return the percentage of trials completed, grouped at the first child level\n    // counts a set of trials as complete when the child node is done\n    this.percentComplete = function() {\n      var total_trials = this.length();\n      var completed_trials = 0;\n      for (var i = 0; i < timeline_parameters.timeline.length; i++) {\n        if (timeline_parameters.timeline[i].isComplete()) {\n          completed_trials += timeline_parameters.timeline[i].length();\n        }\n      }\n      return (completed_trials / total_trials * 100)\n    }\n\n    // resets the node and all subnodes to original state\n    // but increments the current_iteration counter\n    this.reset = function() {\n      progress.current_location = -1;\n      progress.current_repetition = 0;\n      progress.current_variable_set = 0;\n      progress.current_iteration++;\n      progress.done = false;\n      this.setTimelineVariablesOrder();\n      if (typeof timeline_parameters != 'undefined') {\n        for (var i = 0; i < timeline_parameters.timeline.length; i++) {\n          timeline_parameters.timeline[i].reset();\n        }\n      }\n\n    }\n\n    // mark this node as finished\n    this.end = function() {\n      progress.done = true;\n    }\n\n    // recursively end whatever sub-node is running the current trial\n    this.endActiveNode = function() {\n      if (typeof timeline_parameters == 'undefined') {\n        this.end();\n        parent_node.end();\n      } else {\n        timeline_parameters.timeline[progress.current_location].endActiveNode();\n      }\n    }\n\n    // get a unique ID associated with this node\n    // the ID reflects the current iteration through this node.\n    this.ID = function() {\n      var id = \"\";\n      if (typeof parent_node == 'undefined') {\n        return \"0.\" + progress.current_iteration;\n      } else {\n        id += parent_node.ID() + \"-\";\n        id += relative_id + \".\" + progress.current_iteration;\n        return id;\n      }\n    }\n\n    // get the ID of the active trial\n    this.activeID = function() {\n      if (typeof timeline_parameters == 'undefined') {\n        return this.ID();\n      } else {\n        return timeline_parameters.timeline[progress.current_location].activeID();\n      }\n    }\n\n    // get all the data generated within this node\n    this.generatedData = function() {\n      return jsPsych.data.getDataByTimelineNode(this.ID());\n    }\n\n    // get all the trials of a particular type\n    this.trialsOfType = function(type) {\n      if (typeof timeline_parameters == 'undefined'){\n        if (trial_parameters.type == type) {\n          return trial_parameters;\n        } else {\n          return [];\n        }\n      } else {\n        var trials = [];\n        for (var i = 0; i < timeline_parameters.timeline.length; i++) {\n          var t = timeline_parameters.timeline[i].trialsOfType(type);\n          trials = trials.concat(t);\n        }\n        return trials;\n      }\n    }\n\n    // add new trials to end of this timeline\n    this.insert = function(parameters){\n      if(typeof timeline_parameters == 'undefined'){\n        console.error('Cannot add new trials to a trial-level node.');\n      } else {\n        timeline_parameters.timeline.push(\n          new TimelineNode(Object.assign({}, node_trial_data, parameters), self, timeline_parameters.timeline.length)\n        );\n      }\n    }\n\n    // constructor\n    var _construct = function() {\n\n      // store a link to the parent of this node\n      parent_node = parent;\n\n      // create the ID for this node\n      if (typeof parent == 'undefined') {\n        relative_id = 0;\n      } else {\n        relative_id = relativeID;\n      }\n\n      // check if there is a timeline parameter\n      // if there is, then this node has its own timeline\n      if ((typeof parameters.timeline !== 'undefined') || (typeof jsPsych.plugins[trial_type] == 'function')) {\n\n        // create timeline properties\n        timeline_parameters = {\n          timeline: [],\n          loop_function: parameters.loop_function,\n          conditional_function: parameters.conditional_function,\n          sample: parameters.sample,\n          randomize_order: typeof parameters.randomize_order == 'undefined' ? false : parameters.randomize_order,\n          repetitions: typeof parameters.repetitions == 'undefined' ? 1 : parameters.repetitions,\n          timeline_variables: typeof parameters.timeline_variables == 'undefined' ? [{}] : parameters.timeline_variables\n        };\n\n        self.setTimelineVariablesOrder();\n\n        // extract all of the node level data and parameters\n        var node_data = Object.assign({}, parameters);\n        delete node_data.timeline;\n        delete node_data.conditional_function;\n        delete node_data.loop_function;\n        delete node_data.randomize_order;\n        delete node_data.repetitions;\n        delete node_data.timeline_variables;\n        delete node_data.sample;\n        node_trial_data = node_data; // store for later...\n\n        // create a TimelineNode for each element in the timeline\n        for (var i = 0; i < parameters.timeline.length; i++) {\n          // merge parameters\n          var merged_parameters = Object.assign({}, node_data, parameters.timeline[i]);\n          // merge any data from the parent node into child nodes\n          if(typeof node_data.data == 'object' && typeof parameters.timeline[i].data == 'object'){\n            var merged_data = Object.assign({}, node_data.data, parameters.timeline[i].data);\n            merged_parameters.data = merged_data;\n          }\n          timeline_parameters.timeline.push(new TimelineNode(merged_parameters, self, i));\n        }\n      }\n      // if there is no timeline parameter, then this node is a trial node\n      else {\n        // check to see if a valid trial type is defined\n        var trial_type = parameters.type;\n        if (typeof trial_type == 'undefined') {\n          console.error('Trial level node is missing the \"type\" parameter. The parameters for the node are: ' + JSON.stringify(parameters));\n        } else if ((typeof jsPsych.plugins[trial_type] == 'undefined') && (trial_type.toString().replace(/\\s/g,'') != \"function(){returntimeline.timelineVariable(varname);}\")) {\n          console.error('No plugin loaded for trials of type \"' + trial_type + '\"');\n        }\n        // create a deep copy of the parameters for the trial\n        trial_parameters = Object.assign({}, parameters);\n      }\n\n    }();\n  }\n\n  function startExperiment() {\n\n    loaded = true;\n\n    // show progress bar if requested\n    if (opts.show_progress_bar === true) {\n      drawProgressBar(opts.message_progress_bar);\n    }\n\n    // record the start time\n    exp_start_time = new Date();\n\n    // begin!\n    timeline.advance();\n    doTrial(timeline.trial());\n\n  }\n\n  function finishExperiment() {\n\n    if(typeof timeline.end_message !== 'undefined'){\n      DOM_target.innerHTML = timeline.end_message;\n    }\n\n    opts.on_finish(jsPsych.data.get());\n\n  }\n\n  function nextTrial() {\n    // if experiment is paused, don't do anything.\n    if(paused) {\n      waiting = true;\n      return;\n    }\n\n    global_trial_index++;\n\n    // advance timeline\n    timeline.markCurrentTrialComplete();\n    var complete = timeline.advance();\n\n    // update progress bar if shown\n    if (opts.show_progress_bar === true && opts.auto_update_progress_bar == true) {\n      updateProgressBar();\n    }\n\n    // check if experiment is over\n    if (complete) {\n      finishExperiment();\n      return;\n    }\n\n    doTrial(timeline.trial());\n  }\n\n  function doTrial(trial) {\n\n    current_trial = trial;\n    current_trial_finished = false;\n\n    // process all timeline variables for this trial\n    evaluateTimelineVariables(trial);\n\n    // evaluate variables that are functions\n    evaluateFunctionParameters(trial);\n\n    // get default values for parameters\n    setDefaultValues(trial);\n\n    // call experiment wide callback\n    opts.on_trial_start(trial);\n\n    // call trial specific callback if it exists\n    if(typeof trial.on_start == 'function'){\n      trial.on_start(trial);\n    }\n\n    // apply the focus to the element containing the experiment.\n    DOM_container.focus();\n\n    // reset the scroll on the DOM target\n    DOM_target.scrollTop = 0;\n\n    // execute trial method\n    jsPsych.plugins[trial.type].trial(DOM_target, trial);\n\n    // call trial specific loaded callback if it exists\n    if(typeof trial.on_load == 'function'){\n      trial.on_load();\n    }\n  }\n\n  function evaluateTimelineVariables(trial){\n    var keys = Object.keys(trial);\n\n    for (var i = 0; i < keys.length; i++) {\n      // timeline variables on the root level\n      if (typeof trial[keys[i]] == \"function\" && trial[keys[i]].toString().replace(/\\s/g,'') == \"function(){returntimeline.timelineVariable(varname);}\") {\n        trial[keys[i]] = trial[keys[i]].call();\n      }\n      // timeline variables that are nested in objects\n      if (typeof trial[keys[i]] == \"object\" && trial[keys[i]] !== null){\n        evaluateTimelineVariables(trial[keys[i]]);\n      }\n    }\n  }\n\n  function evaluateFunctionParameters(trial){\n\n    // first, eval the trial type if it is a function\n    // this lets users set the plugin type with a function\n    if(typeof trial.type === 'function'){\n      trial.type = trial.type.call();\n    }\n\n    // now eval the whole trial\n\n    // start by getting a list of the parameters\n    var keys = Object.keys(trial);\n\n    // iterate over each parameter\n    for (var i = 0; i < keys.length; i++) {\n      // check to make sure parameter is not \"type\", since that was eval'd above.\n      if(keys[i] !== 'type'){\n        // this if statement is checking to see if the parameter type is expected to be a function, in which case we should NOT evaluate it.\n        // the first line checks if the parameter is defined in the universalPluginParameters set\n        // the second line checks the plugin-specific parameters\n        if(\n          (typeof jsPsych.plugins.universalPluginParameters[keys[i]] !== 'undefined' && jsPsych.plugins.universalPluginParameters[keys[i]].type !== jsPsych.plugins.parameterType.FUNCTION ) ||\n          (typeof jsPsych.plugins[trial.type].info.parameters[keys[i]] !== 'undefined' && jsPsych.plugins[trial.type].info.parameters[keys[i]].type !== jsPsych.plugins.parameterType.FUNCTION)\n        ) {\n          if (typeof trial[keys[i]] == \"function\") {\n            trial[keys[i]] = trial[keys[i]].call();\n          }\n        }\n      }\n      // add a special exception for the data parameter so we can evaluate functions. eventually this could be generalized so that any COMPLEX object type could\n      // be evaluated at the individual parameter level.\n      if(keys[i] == 'data'){\n        var data_params = Object.keys(trial[keys[i]]);\n        for(var j=0; j<data_params.length; j++){\n          if(typeof trial[keys[i]][data_params[j]] == \"function\") {\n            trial[keys[i]][data_params[j]] = trial[keys[i]][data_params[j]].call();\n          }\n        }\n      }\n    }\n  }\n\n  function setDefaultValues(trial){\n    for(var param in jsPsych.plugins[trial.type].info.parameters){\n      // check if parameter is complex with nested defaults\n      if(jsPsych.plugins[trial.type].info.parameters[param].type == jsPsych.plugins.parameterType.COMPLEX){\n        if(jsPsych.plugins[trial.type].info.parameters[param].array == true){\n          // iterate over each entry in the array\n          for(var i in trial[param]){\n            // check each parameter in the plugin description\n            for(var p in jsPsych.plugins[trial.type].info.parameters[param].nested){\n              if(typeof trial[param][i][p] == 'undefined' || trial[param][i][p] === null){\n                if(typeof jsPsych.plugins[trial.type].info.parameters[param].nested[p].default == 'undefined'){\n                  console.error('You must specify a value for the '+p+' parameter (nested in the '+param+' parameter) in the '+trial.type+' plugin.');\n                } else {\n                  trial[param][i][p] = jsPsych.plugins[trial.type].info.parameters[param].nested[p].default;\n                }\n              }\n            }\n          }\n        }\n      }      \n      // if it's not nested, checking is much easier and do that here:\n      else if(typeof trial[param] == 'undefined' || trial[param] === null){\n        if(typeof jsPsych.plugins[trial.type].info.parameters[param].default == 'undefined'){\n          console.error('You must specify a value for the '+param+' parameter in the '+trial.type+' plugin.');\n        } else {\n          trial[param] = jsPsych.plugins[trial.type].info.parameters[param].default;\n        }\n      }\n    }\n  }\n\n  function checkExclusions(exclusions, success, fail){\n    var clear = true;\n\n    // MINIMUM SIZE\n    if(typeof exclusions.min_width !== 'undefined' || typeof exclusions.min_height !== 'undefined'){\n      var mw = typeof exclusions.min_width !== 'undefined' ? exclusions.min_width : 0;\n      var mh = typeof exclusions.min_height !== 'undefined' ? exclusions.min_height : 0;\n      var w = window.innerWidth;\n      var h = window.innerHeight;\n      if(w < mw || h < mh){\n        clear = false;\n        var interval = setInterval(function(){\n          var w = window.innerWidth;\n          var h = window.innerHeight;\n          if(w < mw || h < mh){\n            var msg = '<p>Your browser window is too small to complete this experiment. '+\n              'Please maximize the size of your browser window. If your browser window is already maximized, '+\n              'you will not be able to complete this experiment.</p>'+\n              '<p>The minimum width is '+mw+'px. Your current width is '+w+'px.</p>'+\n              '<p>The minimum height is '+mh+'px. Your current height is '+h+'px.</p>';\n            core.getDisplayElement().innerHTML = msg;\n          } else {\n            clearInterval(interval);\n            core.getDisplayElement().innerHTML = '';\n            checkExclusions(exclusions, success, fail);\n          }\n        }, 100);\n        return; // prevents checking other exclusions while this is being fixed\n      }\n    }\n\n    // WEB AUDIO API\n    if(typeof exclusions.audio !== 'undefined' && exclusions.audio) {\n      if(window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext')){\n        // clear\n      } else {\n        clear = false;\n        var msg = '<p>Your browser does not support the WebAudio API, which means that you will not '+\n          'be able to complete the experiment.</p><p>Browsers that support the WebAudio API include '+\n          'Chrome, Firefox, Safari, and Edge.</p>';\n        core.getDisplayElement().innerHTML = msg;\n        fail();\n        return;\n      }\n    }\n\n    // GO?\n    if(clear){ success(); }\n  }\n\n  function drawProgressBar(msg) {\n    document.querySelector('.jspsych-display-element').insertAdjacentHTML('afterbegin',\n      '<div id=\"jspsych-progressbar-container\">'+\n      '<span>'+\n      msg+ \n      '</span>'+\n      '<div id=\"jspsych-progressbar-outer\">'+\n        '<div id=\"jspsych-progressbar-inner\"></div>'+\n      '</div></div>');\n  }\n\n  function updateProgressBar() {\n    var progress = jsPsych.progress().percent_complete;\n    core.setProgressBar(progress / 100);\n  }\n\n  var progress_bar_amount = 0;\n\n  core.setProgressBar = function(proportion_complete){\n    proportion_complete = Math.max(Math.min(1,proportion_complete),0);\n    document.querySelector('#jspsych-progressbar-inner').style.width = (proportion_complete*100) + \"%\";\n    progress_bar_amount = proportion_complete;\n  }\n\n  core.getProgressBarCompleted = function(){\n    return progress_bar_amount;\n  }\n\n  //Leave a trace in the DOM that jspsych was loaded\n  document.documentElement.setAttribute('jspsych', 'present');\n\n  return core;\n})();\n\njsPsych.plugins = (function() {\n\n  var module = {};\n\n  // enumerate possible parameter types for plugins\n  module.parameterType = {\n    BOOL: 0,\n    STRING: 1,\n    INT: 2,\n    FLOAT: 3,\n    FUNCTION: 4,\n    KEYCODE: 5,\n    SELECT: 6,\n    HTML_STRING: 7,\n    IMAGE: 8,\n    AUDIO: 9,\n    VIDEO: 10,\n    OBJECT: 11,\n    COMPLEX: 12\n  }\n\n  module.universalPluginParameters = {\n    data: {\n      type: module.parameterType.OBJECT,\n      pretty_name: 'Data',\n      default: {},\n      description: 'Data to add to this trial (key-value pairs)'\n    },\n    on_start: {\n      type: module.parameterType.FUNCTION,\n      pretty_name: 'On start',\n      default: function() { return; },\n      description: 'Function to execute when trial begins'\n    },\n    on_finish: {\n      type: module.parameterType.FUNCTION,\n      pretty_name: 'On finish',\n      default: function() { return; },\n      description: 'Function to execute when trial is finished'\n    },\n    on_load: {\n      type: module.parameterType.FUNCTION,\n      pretty_name: 'On load',\n      default: function() { return; },\n      description: 'Function to execute after the trial has loaded'\n    },\n    post_trial_gap: {\n      type: module.parameterType.INT,\n      pretty_name: 'Post trial gap',\n      default: null,\n      description: 'Length of gap between the end of this trial and the start of the next trial'\n    }\n  }\n\n  return module;\n})();\n\njsPsych.data = (function() {\n\n  var module = {};\n\n  // data storage object\n  var allData = DataCollection();\n\n  // browser interaction event data\n  var interactionData = DataCollection();\n\n  // data properties for all trials\n  var dataProperties = {};\n\n  // cache the query_string\n  var query_string;\n\n  // DataCollection\n  function DataCollection(data){\n\n    var data_collection = {};\n\n    var trials = typeof data === 'undefined' ? [] : data;\n\n    data_collection.push = function(new_data){\n      trials.push(new_data);\n      return data_collection;\n    }\n\n    data_collection.join = function(other_data_collection){\n      trials = trials.concat(other_data_collection.values());\n      return data_collection;\n    }\n\n    data_collection.top = function(){\n      if(trials.length <= 1){\n        return data_collection;\n      } else {\n        return DataCollection([trials[trials.length-1]]);\n      }\n    }\n\n    data_collection.first = function(n){\n      if(typeof n=='undefined'){ n = 1 }\n      var out = [];\n      for(var i=0; i<n; i++){\n        out.push(trials[i]);\n      }\n      return DataCollection(out);\n    }\n\n    data_collection.last = function(n){\n      if(typeof n=='undefined'){ n = 1 }\n      var out = [];\n      for(var i=trials.length-n; i<trials.length; i++){\n        out.push(trials[i]);\n      }\n      return DataCollection(out);\n    }\n\n    data_collection.values = function(){\n      return trials;\n    }\n\n    data_collection.count = function(){\n      return trials.length;\n    }\n\n    data_collection.readOnly = function(){\n      return DataCollection(jsPsych.utils.deepCopy(trials));\n    }\n\n    data_collection.addToAll = function(properties){\n      for (var i = 0; i < trials.length; i++) {\n        for (var key in properties) {\n          trials[i][key] = properties[key];\n        }\n      }\n      return data_collection;\n    }\n\n    data_collection.addToLast = function(properties){\n      if(trials.length != 0){\n        for (var key in properties) {\n          trials[trials.length-1][key] = properties[key];\n        }\n      }\n      return data_collection;\n    }\n\n    data_collection.filter = function(filters){\n      // [{p1: v1, p2:v2}, {p1:v2}]\n      // {p1: v1}\n      if(!Array.isArray(filters)){\n        var f = jsPsych.utils.deepCopy([filters]);\n      } else {\n        var f = jsPsych.utils.deepCopy(filters);\n      }\n\n      var filtered_data = [];\n      for(var x=0; x < trials.length; x++){\n        var keep = false;\n        for(var i=0; i<f.length; i++){\n          var match = true;\n          var keys = Object.keys(f[i]);\n          for(var k=0; k<keys.length; k++){\n            if(typeof trials[x][keys[k]] !== 'undefined' && trials[x][keys[k]] == f[i][keys[k]]){\n              // matches on this key!\n            } else {\n              match = false;\n            }\n          }\n          if(match) { keep = true; break; } // can break because each filter is OR.\n        }\n        if(keep){\n          filtered_data.push(trials[x]);\n        }\n      }\n\n      var out = DataCollection(filtered_data);\n\n      return out;\n    }\n\n    data_collection.filterCustom = function(fn){\n      var included = [];\n      for(var i=0; i<trials.length; i++){\n        if(fn(trials[i])){\n          included.push(trials[i]);\n        }\n      }\n      return DataCollection(included);\n    }\n\n    data_collection.select = function(column){\n      var values = [];\n      for(var i=0; i<trials.length; i++){\n        if(typeof trials[i][column] !== 'undefined'){\n          values.push(trials[i][column]);\n        }\n      }\n      var out = DataColumn();\n      out.values = values;\n      return out;\n    }\n\n    data_collection.ignore = function(columns){\n      if(!Array.isArray(columns)){\n        columns = [columns];\n      }\n      var o = jsPsych.utils.deepCopy(trials);\n      for (var i = 0; i < o.length; i++) {\n        for (var j in columns) {\n          delete o[i][columns[j]];\n        }\n      }\n      return DataCollection(o);\n    }\n\n    data_collection.uniqueNames = function(){\n      var names = [];\n\n      for(var i=0; i<trials.length; i++){\n        var keys = Object.keys(trials[i]);\n        for(var j=0; j<keys.length; j++){\n          if(!names.includes(keys[j])){\n            names.push(keys[j]);\n          }\n        }\n      }\n\n      return names;\n    }\n\n    data_collection.csv = function(){\n      return JSON2CSV(trials);\n    }\n\n    data_collection.json = function(pretty){\n      if(pretty){\n        return JSON.stringify(trials, null, '\\t');\n      }\n      return JSON.stringify(trials);\n    }\n\n    data_collection.localSave = function(format, filename){\n      var data_string;\n\n      if (format == 'JSON' || format == 'json') {\n        data_string = data_collection.json();\n      } else if (format == 'CSV' || format == 'csv') {\n        data_string = data_collection.csv();\n      } else {\n        throw new Error('Invalid format specified for localSave. Must be \"JSON\" or \"CSV\".');\n      }\n\n      saveTextToFile(data_string, filename);\n    }\n\n    return data_collection;\n  }\n\n  // DataColumn class\n  function DataColumn(){\n    var data_column = {};\n\n    data_column.values = [];\n\n    data_column.sum = function(){\n      var s = 0;\n      for(var i=0; i<data_column.values.length; i++){\n        s += data_column.values[i];\n      }\n      return s;\n    }\n\n    data_column.mean = function(){\n      return data_column.sum() / data_column.count();\n    }\n\n    data_column.median = function(){\n      if (data_column.values.length == 0) {return undefined};\n      var numbers = data_column.values.slice(0).sort(function(a,b){ return a - b; });\n      var middle = Math.floor(numbers.length / 2);\n      var isEven = numbers.length % 2 === 0;\n      return isEven ? (numbers[middle] + numbers[middle - 1]) / 2 : numbers[middle];\n    }\n\n    data_column.min = function(){\n      return Math.min.apply(null, data_column.values);\n    }\n\n    data_column.max = function(){\n      return Math.max.apply(null, data_column.values);\n    }\n\n    data_column.count = function(){\n      return data_column.values.length;\n    }\n\n    data_column.variance = function(){\n      var mean = data_column.mean();\n      var sum_square_error = 0;\n      for(var i=0; i<data_column.values.length; i++){\n        sum_square_error += Math.pow(data_column.values[i] - mean,2);\n      }\n      var mse = sum_square_error / (data_column.values.length - 1);\n      return mse;\n    }\n\n    data_column.sd = function(){\n      var mse = data_column.variance();\n      var rmse = Math.sqrt(mse);\n      return rmse;\n    }\n\n    data_column.frequencies = function(){\n      var unique = {}\n      for(var i=0; i<data_column.values.length; i++){\n        var v = data_column.values[i];\n        if(typeof unique[v] == 'undefined'){\n          unique[v] = 1;\n        } else {\n          unique[v]++;\n        }\n      }\n      return unique;\n    }\n\n    data_column.all = function(eval_fn){\n      for(var i=0; i<data_column.values.length; i++){\n        if(!eval_fn(data_column.values[i])){\n          return false;\n        }\n      }\n      return true;\n    }\n\n    data_column.subset = function(eval_fn){\n      var out = [];\n      for(var i=0; i<data_column.values.length; i++){\n        if(eval_fn(data_column.values[i])){\n          out.push(data_column.values[i]);\n        }\n      }\n      var o = DataColumn();\n      o.values = out;\n      return o;\n    }\n\n    return data_column;\n  }\n\n  module.reset = function(){\n    allData = DataCollection();\n    interactionData = DataCollection();\n  }\n\n  module.get = function() {\n    return allData;\n  };\n\n  module.getInteractionData = function() {\n    return interactionData;\n  }\n\n  module.write = function(data_object) {\n\n    var progress = jsPsych.progress();\n    var trial = jsPsych.currentTrial();\n\n    //var trial_opt_data = typeof trial.data == 'function' ? trial.data() : trial.data;\n\n    var default_data = {\n      'trial_type': trial.type,\n      'trial_index': progress.current_trial_global,\n      'time_elapsed': jsPsych.totalTime(),\n      'internal_node_id': jsPsych.currentTimelineNodeID()\n    };\n\n    var ext_data_object = Object.assign({}, data_object, trial.data, default_data, dataProperties);\n\n    allData.push(ext_data_object);\n  };\n\n  module.addProperties = function(properties) {\n\n    // first, add the properties to all data that's already stored\n    allData.addToAll(properties);\n\n    // now add to list so that it gets appended to all future data\n    dataProperties = Object.assign({}, dataProperties, properties);\n\n  };\n\n  module.addDataToLastTrial = function(data) {\n    allData.addToLast(data);\n  }\n\n  module.getDataByTimelineNode = function(node_id) {\n    var data = allData.filterCustom(function(x){\n      return x.internal_node_id.slice(0, node_id.length) === node_id;\n    });\n\n    return data;\n  };\n\n  module.getLastTrialData = function() {\n    return allData.top();\n  };\n\n  module.getLastTimelineData = function() {\n    var lasttrial = module.getLastTrialData();\n    var node_id = lasttrial.select('internal_node_id').values[0];\n    if (typeof node_id === 'undefined') {\n      return DataCollection();\n    } else {\n      var parent_node_id = node_id.substr(0,node_id.lastIndexOf('-'));\n      var lastnodedata = module.getDataByTimelineNode(parent_node_id);\n      return lastnodedata;\n    }\n  }\n\n  module.displayData = function(format) {\n    format = (typeof format === 'undefined') ? \"json\" : format.toLowerCase();\n    if (format != \"json\" && format != \"csv\") {\n      console.log('Invalid format declared for displayData function. Using json as default.');\n      format = \"json\";\n    }\n\n    var data_string;\n\n    if (format == 'json') {\n      data_string = allData.json(true); // true = pretty print with tabs\n    } else {\n      data_string = allData.csv();\n    }\n\n    var display_element = jsPsych.getDisplayElement();\n\n    display_element.innerHTML = '<pre id=\"jspsych-data-display\"></pre>';\n\n    document.getElementById('jspsych-data-display').textContent = data_string;\n  };\n\n  module.urlVariables = function() {\n    if(typeof query_string == 'undefined'){\n      query_string = getQueryString();\n    }\n    return query_string;\n  }\n\n  module.getURLVariable = function(whichvar){\n    if(typeof query_string == 'undefined'){\n      query_string = getQueryString();\n    }\n    return query_string[whichvar];\n  }\n\n  module.createInteractionListeners = function(){\n    // blur event capture\n    window.addEventListener('blur', function(){\n      var data = {\n        event: 'blur',\n        trial: jsPsych.progress().current_trial_global,\n        time: jsPsych.totalTime()\n      };\n      interactionData.push(data);\n      jsPsych.initSettings().on_interaction_data_update(data);\n    });\n\n    // focus event capture\n    window.addEventListener('focus', function(){\n      var data = {\n        event: 'focus',\n        trial: jsPsych.progress().current_trial_global,\n        time: jsPsych.totalTime()\n      };\n      interactionData.push(data);\n      jsPsych.initSettings().on_interaction_data_update(data);\n    });\n\n    // fullscreen change capture\n    function fullscreenchange(){\n      var type = (document.isFullScreen || document.webkitIsFullScreen || document.mozIsFullScreen || document.fullscreenElement) ? 'fullscreenenter' : 'fullscreenexit';\n      var data = {\n        event: type,\n        trial: jsPsych.progress().current_trial_global,\n        time: jsPsych.totalTime()\n      };\n      interactionData.push(data);\n      jsPsych.initSettings().on_interaction_data_update(data);\n    }\n\n    document.addEventListener('fullscreenchange', fullscreenchange);\n    document.addEventListener('mozfullscreenchange', fullscreenchange);\n    document.addEventListener('webkitfullscreenchange', fullscreenchange);\n  }\n\n  // public methods for testing purposes. not recommended for use.\n  module._customInsert = function(data){\n    allData = DataCollection(data);\n  }\n\n  module._fullreset = function(){\n    module.reset();\n    dataProperties = {};\n  }\n\n  // private function to save text file on local drive\n  function saveTextToFile(textstr, filename) {\n    var blobToSave = new Blob([textstr], {\n      type: 'text/plain'\n    });\n    var blobURL = \"\";\n    if (typeof window.webkitURL !== 'undefined') {\n      blobURL = window.webkitURL.createObjectURL(blobToSave);\n    } else {\n      blobURL = window.URL.createObjectURL(blobToSave);\n    }\n\n    var display_element = jsPsych.getDisplayElement();\n\n    display_element.insertAdjacentHTML('beforeend','<a id=\"jspsych-download-as-text-link\" style=\"display:none;\" download=\"'+filename+'\" href=\"'+blobURL+'\">click to download</a>');\n    document.getElementById('jspsych-download-as-text-link').click();\n  }\n\n  //\n  // A few helper functions to handle data format conversion\n  //\n\n  // this function based on code suggested by StackOverflow users:\n  // http://stackoverflow.com/users/64741/zachary\n  // http://stackoverflow.com/users/317/joseph-sturtevant\n\n  function JSON2CSV(objArray) {\n    var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;\n    var line = '';\n    var result = '';\n    var columns = [];\n\n    var i = 0;\n    for (var j = 0; j < array.length; j++) {\n      for (var key in array[j]) {\n        var keyString = key + \"\";\n        keyString = '\"' + keyString.replace(/\"/g, '\"\"') + '\",';\n        if (!columns.includes(key)) {\n          columns[i] = key;\n          line += keyString;\n          i++;\n        }\n      }\n    }\n\n    line = line.slice(0, -1);\n    result += line + '\\r\\n';\n\n    for (var i = 0; i < array.length; i++) {\n      var line = '';\n      for (var j = 0; j < columns.length; j++) {\n        var value = (typeof array[i][columns[j]] === 'undefined') ? '' : array[i][columns[j]];\n        var valueString = value + \"\";\n        line += '\"' + valueString.replace(/\"/g, '\"\"') + '\",';\n      }\n\n      line = line.slice(0, -1);\n      result += line + '\\r\\n';\n    }\n\n    return result;\n  }\n\n  // this function is modified from StackOverflow:\n  // http://stackoverflow.com/posts/3855394\n\n  function getQueryString() {\n    var a = window.location.search.substr(1).split('&');\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i)\n    {\n        var p=a[i].split('=', 2);\n        if (p.length == 1)\n            b[p[0]] = \"\";\n        else\n            b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n    }\n    return b;\n  }\n\n  return module;\n\n})();\n\njsPsych.turk = (function() {\n\n  var module = {};\n\n  // core.turkInfo gets information relevant to mechanical turk experiments. returns an object\n  // containing the workerID, assignmentID, and hitID, and whether or not the HIT is in\n  // preview mode, meaning that they haven't accepted the HIT yet.\n  module.turkInfo = function() {\n\n    var turk = {};\n\n    var param = function(url, name) {\n      name = name.replace(/[\\[]/, \"\\\\\\[\").replace(/[\\]]/, \"\\\\\\]\");\n      var regexS = \"[\\\\?&]\" + name + \"=([^&#]*)\";\n      var regex = new RegExp(regexS);\n      var results = regex.exec(url);\n      return (results == null) ? \"\" : results[1];\n    };\n\n    var src = param(window.location.href, \"assignmentId\") ? window.location.href : document.referrer;\n\n    var keys = [\"assignmentId\", \"hitId\", \"workerId\", \"turkSubmitTo\"];\n    keys.map(\n\n      function(key) {\n        turk[key] = unescape(param(src, key));\n      });\n\n    turk.previewMode = (turk.assignmentId == \"ASSIGNMENT_ID_NOT_AVAILABLE\");\n\n    turk.outsideTurk = (!turk.previewMode && turk.hitId === \"\" && turk.assignmentId == \"\" && turk.workerId == \"\")\n\n    turk_info = turk;\n\n    return turk;\n\n  };\n\n  // core.submitToTurk will submit a MechanicalTurk ExternalHIT type\n  module.submitToTurk = function(data) {\n\n    var turkInfo = jsPsych.turk.turkInfo();\n    var assignmentId = turkInfo.assignmentId;\n    var turkSubmitTo = turkInfo.turkSubmitTo;\n\n    if (!assignmentId || !turkSubmitTo) return;\n\n    var dataString = [];\n\n    for (var key in data) {\n\n      if (data.hasOwnProperty(key)) {\n        dataString.push(key + \"=\" + escape(data[key]));\n      }\n    }\n\n    dataString.push(\"assignmentId=\" + assignmentId);\n\n    var url = turkSubmitTo + \"/mturk/externalSubmit?\" + dataString.join(\"&\");\n\n    window.location.href = url;\n  };\n\n  return module;\n\n})();\n\njsPsych.randomization = (function() {\n\n  var module = {};\n\n  module.repeat = function(array, repetitions, unpack) {\n\n    var arr_isArray = Array.isArray(array);\n    var rep_isArray = Array.isArray(repetitions);\n\n    // if array is not an array, then we just repeat the item\n    if (!arr_isArray) {\n      if (!rep_isArray) {\n        array = [array];\n        repetitions = [repetitions];\n      } else {\n        repetitions = [repetitions[0]];\n        console.log('Unclear parameters given to randomization.repeat. Multiple set sizes specified, but only one item exists to sample. Proceeding using the first set size.');\n      }\n    } else {\n      if (!rep_isArray) {\n        var reps = [];\n        for (var i = 0; i < array.length; i++) {\n          reps.push(repetitions);\n        }\n        repetitions = reps;\n      } else {\n        if (array.length != repetitions.length) {\n          console.warning('Unclear parameters given to randomization.repeat. Items and repetitions are unequal lengths. Behavior may not be as expected.');\n          // throw warning if repetitions is too short, use first rep ONLY.\n          if (repetitions.length < array.length) {\n            var reps = [];\n            for (var i = 0; i < array.length; i++) {\n              reps.push(repetitions);\n            }\n            repetitions = reps;\n          } else {\n            // throw warning if too long, and then use the first N\n            repetitions = repetions.slice(0, array.length);\n          }\n        }\n      }\n    }\n\n    // should be clear at this point to assume that array and repetitions are arrays with == length\n    var allsamples = [];\n    for (var i = 0; i < array.length; i++) {\n      for (var j = 0; j < repetitions[i]; j++) {\n        if(array[i] == null || typeof array[i] != 'object'){\n          allsamples.push(array[i]);\n        } else {\n          allsamples.push(Object.assign({}, array[i]));\n        }\n\n      }\n    }\n\n    var out = shuffle(allsamples);\n\n    if (unpack) {\n      out = unpackArray(out);\n    }\n\n    return out;\n  }\n\n  module.shuffle = function(arr) {\n    if(!Array.isArray(arr)){\n      console.error('Argument to jsPsych.randomization.shuffle() must be an array.')\n    }\n    return shuffle(arr);\n  }\n\n  module.shuffleNoRepeats = function(arr, equalityTest) {\n    if(!Array.isArray(arr)){\n      console.error('First argument to jsPsych.randomization.shuffleNoRepeats() must be an array.')\n    }\n    if(typeof equalityTest !== 'undefined' || typeof equalityTest !== 'function'){\n      console.error('Second argument to jsPsych.randomization.shuffleNoRepeats() must be a function.')\n    }\n    // define a default equalityTest\n    if (typeof equalityTest == 'undefined') {\n      equalityTest = function(a, b) {\n        if (a === b) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n\n    var random_shuffle = shuffle(arr);\n    for (var i = 0; i < random_shuffle.length - 1; i++) {\n      if (equalityTest(random_shuffle[i], random_shuffle[i + 1])) {\n        // neighbors are equal, pick a new random neighbor to swap (not the first or last element, to avoid edge cases)\n        var random_pick = Math.floor(Math.random() * (random_shuffle.length - 2)) + 1;\n        // test to make sure the new neighbor isn't equal to the old one\n        while (\n          equalityTest(random_shuffle[i + 1], random_shuffle[random_pick]) ||\n          (equalityTest(random_shuffle[i + 1], random_shuffle[random_pick + 1]) || equalityTest(random_shuffle[i + 1], random_shuffle[random_pick - 1]))\n        ) {\n          random_pick = Math.floor(Math.random() * (random_shuffle.length - 2)) + 1;\n        }\n        var new_neighbor = random_shuffle[random_pick];\n        random_shuffle[random_pick] = random_shuffle[i + 1];\n        random_shuffle[i + 1] = new_neighbor;\n      }\n    }\n\n    return random_shuffle;\n  }\n\n  module.shuffleAlternateGroups = function(arr_groups, random_group_order){\n    if(typeof random_group_order == 'undefined'){\n      random_group_order = false;\n    }\n\n    var n_groups = arr_groups.length;\n    if(n_groups == 1){\n      console.warn('jsPsych.randomization.shuffleAlternateGroups was called with only one group. Defaulting to simple shuffle.');\n      return(module.shuffle(arr_groups[0]));\n    }\n\n    var group_order = [];\n    for(var i=0; i<n_groups; i++){\n      group_order.push(i);\n    }\n    if(random_group_order){\n      group_order = module.shuffle(group_order);\n    }\n\n    var randomized_groups = [];\n    var min_length = null;\n    for(var i=0; i<n_groups; i++){\n      min_length = min_length === null ? arr_groups[i].length : Math.min(min_length, arr_groups[i].length);\n      randomized_groups.push(module.shuffle(arr_groups[i]));\n    }\n\n    var out = [];\n    for(var i=0; i<min_length; i++){\n      for(var j=0; j<group_order.length; j++){\n        out.push(randomized_groups[group_order[j]][i])\n      }\n    }\n\n    return out;\n  }\n\n  module.sampleWithoutReplacement = function(arr, size){\n    if(!Array.isArray(arr)){\n      console.error(\"First argument to jsPsych.randomization.sampleWithoutReplacement() must be an array\")\n    }\n    \n    if (size > arr.length) {\n      console.error(\"Cannot take a sample \" +\n        \"larger than the size of the set of items to sample.\");\n    }\n    return jsPsych.randomization.shuffle(arr).slice(0,size);\n  }\n\n  module.sampleWithReplacement = function(arr, size, weights) {\n    if(!Array.isArray(arr)){\n      console.error(\"First argument to jsPsych.randomization.sampleWithReplacement() must be an array\")\n    }\n\n    var normalized_weights = [];\n    if(typeof weights !== 'undefined'){\n      if(weights.length !== arr.length){\n        console.error('The length of the weights array must equal the length of the array '+\n        'to be sampled from.');\n      }\n      var weight_sum = 0;\n      for(var i=0; i<weights.length; i++){\n        weight_sum += weights[i];\n      }\n      for(var i=0; i<weights.length; i++){\n        normalized_weights.push( weights[i] / weight_sum );\n      }\n    } else {\n      for(var i=0; i<arr.length; i++){\n        normalized_weights.push( 1 / arr.length );\n      }\n    }\n\n    var cumulative_weights = [normalized_weights[0]];\n    for(var i=1; i<normalized_weights.length; i++){\n      cumulative_weights.push(normalized_weights[i] + cumulative_weights[i-1]);\n    }\n\n    var samp = [];\n    for (var i = 0; i < size; i++) {\n      var rnd = Math.random();\n      var index = 0;\n      while(rnd > cumulative_weights[index]) { index++; }\n      samp.push(arr[index]);\n    }\n    return samp;\n  }\n\n  module.factorial = function(factors, repetitions, unpack) {\n\n    var factorNames = Object.keys(factors);\n\n    var factor_combinations = [];\n\n    for (var i = 0; i < factors[factorNames[0]].length; i++) {\n      factor_combinations.push({});\n      factor_combinations[i][factorNames[0]] = factors[factorNames[0]][i];\n    }\n\n    for (var i = 1; i < factorNames.length; i++) {\n      var toAdd = factors[factorNames[i]];\n      var n = factor_combinations.length;\n      for (var j = 0; j < n; j++) {\n        var base = factor_combinations[j];\n        for (var k = 0; k < toAdd.length; k++) {\n          var newpiece = {};\n          newpiece[factorNames[i]] = toAdd[k];\n          factor_combinations.push(Object.assign({}, base, newpiece));\n        }\n      }\n      factor_combinations.splice(0, n);\n    }\n\n    repetitions = (typeof repetitions === 'undefined') ? 1 : repetitions;\n    var with_repetitions = module.repeat(factor_combinations, repetitions, unpack);\n\n    return with_repetitions;\n  }\n\n  module.randomID = function(length){\n    var result = '';\n    var length = (typeof length == 'undefined') ? 32 : length;\n    var chars = '0123456789abcdefghjklmnopqrstuvwxyz';\n    for(var i = 0; i<length; i++){\n      result += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return result;\n  }\n\n  function unpackArray(array) {\n\n    var out = {};\n\n    for (var i = 0; i < array.length; i++) {\n      var keys = Object.keys(array[i]);\n      for (var k = 0; k < keys.length; k++) {\n        if (typeof out[keys[k]] === 'undefined') {\n          out[keys[k]] = [];\n        }\n        out[keys[k]].push(array[i][keys[k]]);\n      }\n    }\n\n    return out;\n  }\n\n  function shuffle(array) {\n    var copy_array = array.slice(0);\n    var m = copy_array.length,\n      t, i;\n\n    // While there remain elements to shuffle\n    while (m) {\n\n      // Pick a remaining element\n      i = Math.floor(Math.random() * m--);\n\n      // And swap it with the current element.\n      t = copy_array[m];\n      copy_array[m] = copy_array[i];\n      copy_array[i] = t;\n    }\n\n    return copy_array;\n  }\n\n  return module;\n\n})();\n\njsPsych.pluginAPI = (function() {\n\n  var module = {};\n\n  // keyboard listeners //\n\n  var keyboard_listeners = [];\n\n  var held_keys = {};\n\n  var root_keydown_listener = function(e){\n    for(var i=0; i<keyboard_listeners.length; i++){\n      keyboard_listeners[i].fn(e);\n    }\n    held_keys[e.keyCode] = true;\n  }\n  var root_keyup_listener = function(e){\n    held_keys[e.keyCode] = false;\n  }\n\n  module.reset = function(root_element){\n    keyboard_listeners = [];\n    held_keys = {};\n    root_element.removeEventListener('keydown', root_keydown_listener);\n    root_element.removeEventListener('keyup', root_keyup_listener);\n  }\n\n  module.createKeyboardEventListeners = function(root_element){\n    root_element.addEventListener('keydown', root_keydown_listener);\n    root_element.addEventListener('keyup', root_keyup_listener);\n  }\n\n  module.getKeyboardResponse = function(parameters) {\n    //parameters are: callback_function, valid_responses, rt_method, persist, audio_context, audio_context_start_time, allow_held_key?\n\n    parameters.rt_method = (typeof parameters.rt_method === 'undefined') ? 'performance' : parameters.rt_method;\n    if (parameters.rt_method != 'performance' && parameters.rt_method != 'audio') {\n      console.log('Invalid RT method specified in getKeyboardResponse. Defaulting to \"performance\" method.');\n      parameters.rt_method = 'performance';\n    }\n\n    var start_time;\n    if (parameters.rt_method == 'performance') {\n      start_time = performance.now();\n    } else if (parameters.rt_method == 'audio') {\n      start_time = parameters.audio_context_start_time;\n    }\n\n    var listener_id;\n\n    var listener_function = function(e) {\n\n      var key_time;\n      if (parameters.rt_method == 'performance') {\n        key_time = performance.now();\n      } else if (parameters.rt_method == 'audio') {\n        key_time = parameters.audio_context.currentTime\n      }\n\n      var valid_response = false;\n      if (typeof parameters.valid_responses === 'undefined' || parameters.valid_responses == jsPsych.ALL_KEYS) {\n        valid_response = true;\n      } else {\n        if(parameters.valid_responses != jsPsych.NO_KEYS){\n          for (var i = 0; i < parameters.valid_responses.length; i++) {\n            if (typeof parameters.valid_responses[i] == 'string') {\n              var kc = jsPsych.pluginAPI.convertKeyCharacterToKeyCode(parameters.valid_responses[i]);\n              if (typeof kc !== 'undefined') {\n                if (e.keyCode == kc) {\n                  valid_response = true;\n                }\n              } else {\n                throw new Error('Invalid key string specified for getKeyboardResponse');\n              }\n            } else if (e.keyCode == parameters.valid_responses[i]) {\n              valid_response = true;\n            }\n          }\n        }\n      }\n      // check if key was already held down\n\n      if (((typeof parameters.allow_held_key == 'undefined') || !parameters.allow_held_key) && valid_response) {\n        if (typeof held_keys[e.keyCode] !== 'undefined' && held_keys[e.keyCode] == true) {\n          valid_response = false;\n        }\n      }\n\n      if (valid_response) {\n        // if this is a valid response, then we don't want the key event to trigger other actions\n        // like scrolling via the spacebar.\n        e.preventDefault();\n\n        parameters.callback_function({\n          key: e.keyCode,\n          rt: key_time - start_time\n        });\n\n        if (keyboard_listeners.includes(listener_id)) {\n\n          if (!parameters.persist) {\n            // remove keyboard listener\n            module.cancelKeyboardResponse(listener_id);\n          }\n        }\n      }\n    };\n\n    // create listener id object\n    listener_id = {\n      type: 'keydown',\n      fn: listener_function\n    };\n\n    // add this keyboard listener to the list of listeners\n    keyboard_listeners.push(listener_id);\n\n    return listener_id;\n\n  };\n\n  module.cancelKeyboardResponse = function(listener) {\n    // remove the listener from the list of listeners\n    if (keyboard_listeners.includes(listener)) {\n      keyboard_listeners.splice(keyboard_listeners.indexOf(listener), 1);\n    }\n  };\n\n  module.cancelAllKeyboardResponses = function() {\n    keyboard_listeners = [];\n  };\n\n  module.convertKeyCharacterToKeyCode = function(character) {\n    var code;\n    character = character.toLowerCase();\n    if (typeof keylookup[character] !== 'undefined') {\n      code = keylookup[character];\n    }\n    return code;\n  }\n\n  module.convertKeyCodeToKeyCharacter = function(code){\n    for(var i in Object.keys(keylookup)){\n      if(keylookup[Object.keys(keylookup)[i]] == code){\n        return Object.keys(keylookup)[i];\n      }\n    }\n    return undefined;\n  }\n\n  module.compareKeys = function(key1, key2){\n    // convert to numeric values no matter what\n    if(typeof key1 == 'string') {\n      key1 = module.convertKeyCharacterToKeyCode(key1);\n    }\n    if(typeof key2 == 'string') {\n      key2 = module.convertKeyCharacterToKeyCode(key2);\n    }\n    return key1 == key2;\n  }\n\n  var keylookup = {\n    'backspace': 8,\n    'tab': 9,\n    'enter': 13,\n    'shift': 16,\n    'ctrl': 17,\n    'alt': 18,\n    'pause': 19,\n    'capslock': 20,\n    'esc': 27,\n    'space': 32,\n    'spacebar': 32,\n    ' ': 32,\n    'pageup': 33,\n    'pagedown': 34,\n    'end': 35,\n    'home': 36,\n    'leftarrow': 37,\n    'uparrow': 38,\n    'rightarrow': 39,\n    'downarrow': 40,\n    'insert': 45,\n    'delete': 46,\n    '0': 48,\n    '1': 49,\n    '2': 50,\n    '3': 51,\n    '4': 52,\n    '5': 53,\n    '6': 54,\n    '7': 55,\n    '8': 56,\n    '9': 57,\n    'a': 65,\n    'b': 66,\n    'c': 67,\n    'd': 68,\n    'e': 69,\n    'f': 70,\n    'g': 71,\n    'h': 72,\n    'i': 73,\n    'j': 74,\n    'k': 75,\n    'l': 76,\n    'm': 77,\n    'n': 78,\n    'o': 79,\n    'p': 80,\n    'q': 81,\n    'r': 82,\n    's': 83,\n    't': 84,\n    'u': 85,\n    'v': 86,\n    'w': 87,\n    'x': 88,\n    'y': 89,\n    'z': 90,\n    '0numpad': 96,\n    '1numpad': 97,\n    '2numpad': 98,\n    '3numpad': 99,\n    '4numpad': 100,\n    '5numpad': 101,\n    '6numpad': 102,\n    '7numpad': 103,\n    '8numpad': 104,\n    '9numpad': 105,\n    'multiply': 106,\n    'plus': 107,\n    'minus': 109,\n    'decimal': 110,\n    'divide': 111,\n    'f1': 112,\n    'f2': 113,\n    'f3': 114,\n    'f4': 115,\n    'f5': 116,\n    'f6': 117,\n    'f7': 118,\n    'f8': 119,\n    'f9': 120,\n    'f10': 121,\n    'f11': 122,\n    'f12': 123,\n    '=': 187,\n    ',': 188,\n    '.': 190,\n    '/': 191,\n    '`': 192,\n    '[': 219,\n    '\\\\': 220,\n    ']': 221\n  };\n\n  // timeout registration\n\n  var timeout_handlers = [];\n\n  module.setTimeout = function(callback, delay){\n    var handle = setTimeout(callback, delay);\n    timeout_handlers.push(handle);\n    return handle;\n  }\n\n  module.clearAllTimeouts = function(){\n    for(var i=0;i<timeout_handlers.length; i++){\n      clearTimeout(timeout_handlers[i]);\n    }\n    timeout_handlers = [];\n  }\n\n  // video //\n    var video_buffers = {}\n    module.getVideoBuffer = function(videoID) {\n      return video_buffers[videoID]\n    }\n\n  // audio //\n  var context = null;\n  var audio_buffers = [];\n\n  module.initAudio = function(){\n    context = (jsPsych.initSettings().use_webaudio === true) ? jsPsych.webaudio_context : null;\n  }\n\n  module.audioContext = function(){\n    if(context !== null){\n      if(context.state !== 'running'){\n        context.resume();\n      }\n    }\n    return context;\n  }\n\n  module.getAudioBuffer = function(audioID) {\n\n    if (audio_buffers[audioID] === 'tmp') {\n      console.error('Audio file failed to load in the time allotted.')\n      return;\n    }\n\n    return audio_buffers[audioID];\n\n  }\n\n  // preloading stimuli //\n\n  var preloads = [];\n\n  var img_cache = {};\n\n  module.preloadAudioFiles = function(files, callback_complete, callback_load) {\n\n    files = jsPsych.utils.flatten(files);\n    files = jsPsych.utils.unique(files);\n\n    var n_loaded = 0;\n    var loadfn = (typeof callback_load === 'undefined') ? function() {} : callback_load;\n    var finishfn = (typeof callback_complete === 'undefined') ? function() {} : callback_complete;\n\n    if(files.length==0){\n      finishfn();\n      return;\n    }\n\n    function load_audio_file_webaudio(source, count){\n      count = count || 1;\n      var request = new XMLHttpRequest();\n      request.open('GET', source, true);\n      request.responseType = 'arraybuffer';\n      request.onload = function() {\n        context.decodeAudioData(request.response, function(buffer) {\n          audio_buffers[source] = buffer;\n          n_loaded++;\n          loadfn(n_loaded);\n          if(n_loaded == files.length) {\n            finishfn();\n          }\n        }, function() {\n          console.error('Error loading audio file: ' + bufferID);\n        });\n      }\n      request.onerror = function(){\n        if(count < jsPsych.initSettings().max_preload_attempts){\n          setTimeout(function(){\n            load_audio_file_webaudio(source, count+1)\n          }, 200);\n        } else {\n          jsPsych.loadFail();\n        }\n      }\n      request.send();\n    }\n\n    function load_audio_file_html5audio(source, count){\n      count = count || 1;\n      var audio = new Audio();\n      audio.addEventListener('canplaythrough', function(){\n        audio_buffers[source] = audio;\n        n_loaded++;\n        loadfn(n_loaded);\n        if(n_loaded == files.length){\n          finishfn();\n        }\n      });\n      audio.addEventListener('onerror', function(){\n        if(count < jsPsych.initSettings().max_preload_attempts){\n          setTimeout(function(){\n            load_audio_file_html5audio(source, count+1)\n          }, 200);\n        } else {\n          jsPsych.loadFail();\n        }\n      });\n      audio.addEventListener('onstalled', function(){\n        if(count < jsPsych.initSettings().max_preload_attempts){\n          setTimeout(function(){\n            load_audio_file_html5audio(source, count+1)\n          }, 200);\n        } else {\n          jsPsych.loadFail();\n        }\n      });\n      audio.addEventListener('onabort', function(){\n        if(count < jsPsych.initSettings().max_preload_attempts){\n          setTimeout(function(){\n            load_audio_file_html5audio(source, count+1)\n          }, 200);\n        } else {\n          jsPsych.loadFail();\n        }\n      });\n      audio.src = source;\n    }\n\n    for (var i = 0; i < files.length; i++) {\n      var bufferID = files[i];\n      if (typeof audio_buffers[bufferID] !== 'undefined') {\n        n_loaded++;\n        loadfn(n_loaded);\n        if(n_loaded == files.length) {\n          finishfn();\n        }\n      } else {\n        audio_buffers[bufferID] = 'tmp';\n        if(module.audioContext() !== null){\n          load_audio_file_webaudio(bufferID);\n        } else {\n          load_audio_file_html5audio(bufferID);\n        }\n      }\n    }\n\n  }\n\n  module.preloadImages = function(images, callback_complete, callback_load) {\n\n    // flatten the images array\n    images = jsPsych.utils.flatten(images);\n    images = jsPsych.utils.unique(images);\n\n    var n_loaded = 0;\n    var loadfn = (typeof callback_load === 'undefined') ? function() {} : callback_load;\n    var finishfn = (typeof callback_complete === 'undefined') ? function() {} : callback_complete;\n\n    if(images.length === 0){\n      finishfn();\n      return;\n    }\n\n    function preload_image(source, count){\n      count = count || 1;\n\n      var img = new Image();\n\n      img.onload = function() {\n        n_loaded++;\n        loadfn(n_loaded);\n        if (n_loaded === images.length) {\n          finishfn();\n        }\n      };\n\n      img.onerror = function() {\n        if(count < jsPsych.initSettings().max_preload_attempts){\n          setTimeout(function(){\n            preload_image(source, count+1);\n          }, 200);\n        } else {\n          jsPsych.loadFail();\n        }\n      }\n\n      img.src = source;\n\n      img_cache[source] = img;\n    }\n\n    for (var i = 0; i < images.length; i++) {\n      preload_image(images[i]);\n    }\n\n  };\n\n    module.preloadVideo = function(video, callback_complete, callback_load) {\n\n        // flatten the images array\n        video = jsPsych.utils.flatten(video);\n        video = jsPsych.utils.unique(video);\n\n        var n_loaded = 0;\n        var loadfn = !callback_load ? function() {} : callback_load;\n        var finishfn = !callback_complete ? function() {} : callback_complete;\n\n        if(video.length===0){\n            finishfn();\n            return;\n        }\n\n        function preload_video(source, count){\n            count = count || 1;\n            //based on option 4 here: http://dinbror.dk/blog/how-to-preload-entire-html5-video-before-play-solved/\n            var request = new XMLHttpRequest();\n            request.open('GET', source, true);\n            request.responseType = 'blob';\n            request.onload = function() {\n                if (this.status === 200 || this.status === 0) {\n                    var videoBlob = this.response;\n                    video_buffers[source] = URL.createObjectURL(videoBlob); // IE10+\n                    n_loaded++;\n                    loadfn(n_loaded);\n                    if (n_loaded === video.length) {\n                        finishfn();\n                    }\n                }\n            };\n\n            request.onerror = function(){\n                if(count < jsPsych.initSettings().max_preload_attempts){\n                    setTimeout(function(){\n                        preload_video(source, count+1)\n                    }, 200);\n                } else {\n                    jsPsych.loadFail();\n                }\n            }\n            request.send();\n        }\n\n        for (var i = 0; i < video.length; i++) {\n            preload_video(video[i]);\n        }\n\n    };\n\n  module.registerPreload = function(plugin_name, parameter, media_type, conditional_function) {\n    if (['audio', 'image', 'video'].indexOf(media_type)===-1) {\n      console.error('Invalid media_type parameter for jsPsych.pluginAPI.registerPreload. Please check the plugin file.');\n    }\n\n    var preload = {\n      plugin: plugin_name,\n      parameter: parameter,\n      media_type: media_type,\n      conditional_function: conditional_function\n    }\n\n    preloads.push(preload);\n  }\n\n  module.autoPreload = function(timeline, callback, images, audio, video, progress_bar) {\n    // list of items to preload\n    images = images || [];\n    audio = audio || [];\n    video = video || [];\n\n    // construct list\n    for (var i = 0; i < preloads.length; i++) {\n      var type = preloads[i].plugin;\n      var param = preloads[i].parameter;\n      var media = preloads[i].media_type;\n      var func = preloads[i].conditional_function;\n      var trials = timeline.trialsOfType(type);\n      for (var j = 0; j < trials.length; j++) {\n\n        if (trials[j][param] && typeof trials[j][param] !== 'function') {\n\n          if ( !func  || func(trials[j]) ){\n            if (media === 'image') {\n              images = images.concat(jsPsych.utils.flatten([trials[j][param]]));\n            } else if (media === 'audio') {\n              audio = audio.concat(jsPsych.utils.flatten([trials[j][param]]));\n            }\n            else if (media === 'video') {\n              video = video.concat(jsPsych.utils.flatten([trials[j][param]]));\n            }\n          }\n        }\n      }\n    }\n\n    images = jsPsych.utils.unique(jsPsych.utils.flatten(images));\n    audio  = jsPsych.utils.unique(jsPsych.utils.flatten(audio));\n    video  = jsPsych.utils.unique(jsPsych.utils.flatten(video));\n\n    // remove any nulls false values\n    images = images.filter(function(x) { return x != false && x != null})\n    audio = audio.filter(function(x) { return x != false && x != null})\n    video = video.filter(function(x) { return x != false && x != null})\n    \n    var total_n = images.length + audio.length + video.length;\n\n    var loaded = 0;\n\n    if(progress_bar){\n      var pb_html = \"<div id='jspsych-loading-progress-bar-container' style='height: 10px; width: 300px; background-color: #ddd;'>\";\n      pb_html += \"<div id='jspsych-loading-progress-bar' style='height: 10px; width: 0%; background-color: #777;'></div>\";\n      pb_html += \"</div>\";\n      jsPsych.getDisplayElement().innerHTML = pb_html;\n    }\n\n    function update_loading_progress_bar(){\n      loaded++;\n      if(progress_bar){\n        var percent_loaded = (loaded/total_n)*100;\n        jsPsych.getDisplayElement().querySelector('#jspsych-loading-progress-bar').style.width = percent_loaded+\"%\";\n      }\n    }\n\n    // do the preloading\n    // first the images, then when the images are complete\n    // wait for the audio files to finish\n    module.preloadImages(images, function() {\n      module.preloadAudioFiles(audio, function() {\n          module.preloadVideo(video, function() {\n              callback();\n          }, update_loading_progress_bar);\n      }, update_loading_progress_bar);\n    }, update_loading_progress_bar);\n  }\n\n  /**\n   * Allows communication with user hardware through our custom Google Chrome extension + native C++ program\n   * @param\t\t{object}\tmess\tThe message to be passed to our extension, see its documentation for the expected members of this object.\n   * @author\tDaniel Rivas\n   *\n   */\n  module.hardware = function hardware(mess){\n\t  //since Chrome extension content-scripts do not share the javascript environment with the page script that loaded jspsych,\n\t  //we will need to use hacky methods like communicating through DOM events.\n\t  var jspsychEvt = new CustomEvent('jspsych', {detail: mess});\n\t  document.dispatchEvent(jspsychEvt);\n\t  //And voila! it will be the job of the content script injected by the extension to listen for the event and do the appropriate actions.\n  };\n\n  /** {boolean} Indicates whether this instance of jspsych has opened a hardware connection through our browser extension */\n  module.hardwareConnected = false;\n\n\n  //it might be useful to open up a line of communication from the extension back to this page script,\n  //again, this will have to pass through DOM events. For now speed is of no concern so I will use jQuery\n  document.addEventListener(\"jspsych-activate\", function(evt){\n\t  module.hardwareConnected = true;\n  })\n\n\n\n  return module;\n})();\n\n// methods used in multiple modules //\njsPsych.utils = (function() {\n\n\tvar module = {};\n\n\tmodule.flatten = function(arr, out) {\n\t\tout = (typeof out === 'undefined') ? [] : out;\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (Array.isArray(arr[i])) {\n\t\t\t\tmodule.flatten(arr[i], out);\n\t\t\t} else {\n\t\t\t\tout.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tmodule.unique = function(arr) {\n\t\tvar out = [];\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr.indexOf(arr[i]) == i) {\n\t\t\t\tout.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tmodule.deepCopy = function(obj) {\n    if(!obj) return obj;\n    var out;\n    if(Array.isArray(obj)){\n      out = [];\n      for(var i = 0; i<obj.length; i++){\n        out.push(module.deepCopy(obj[i]));\n      }\n      return out;\n    } else if(typeof obj === 'object'){\n      out = {};\n      for(var key in obj){\n        if(obj.hasOwnProperty(key)){\n          out[key] = module.deepCopy(obj[key]);\n        }\n      }\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n\treturn module;\n})();\n\n// polyfill for Object.assign to support IE\nif (typeof Object.assign != 'function') {\n  Object.assign = function (target, varArgs) { // .length of function is 2\n    'use strict';\n    if (target == null) { // TypeError if undefined or null\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var to = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var nextSource = arguments[index];\n\n      if (nextSource != null) { // Skip over if undefined or null\n        for (var nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  };\n}\n\n// polyfill for Array.includes to support IE\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement /*, fromIndex*/) {\n    'use strict';\n    if (this == null) {\n      throw new TypeError('Array.prototype.includes called on null or undefined');\n    }\n\n    var O = Object(this);\n    var len = parseInt(O.length, 10) || 0;\n    if (len === 0) {\n      return false;\n    }\n    var n = parseInt(arguments[1], 10) || 0;\n    var k;\n    if (n >= 0) {\n      k = n;\n    } else {\n      k = len + n;\n      if (k < 0) {k = 0;}\n    }\n    var currentElement;\n    while (k < len) {\n      currentElement = O[k];\n      if (searchElement === currentElement ||\n         (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN\n        return true;\n      }\n      k++;\n    }\n    return false;\n  };\n}\n\n// polyfill for Array.isArray\nif (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n"},738:function(n,e){n.exports="/**\n * jspsych-html-button-response\n * Josh de Leeuw\n *\n * plugin for displaying a stimulus and getting a keyboard response\n *\n * documentation: docs.jspsych.org\n *\n **/\n\njsPsych.plugins[\"html-button-response\"] = (function() {\n\n  var plugin = {};\n\n  plugin.info = {\n    name: 'html-button-response',\n    description: '',\n    parameters: {\n      stimulus: {\n        type: jsPsych.plugins.parameterType.HTML_STRING,\n        pretty_name: 'Stimulus',\n        default: undefined,\n        description: 'The HTML string to be displayed'\n      },\n      choices: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Choices',\n        default: undefined,\n        array: true,\n        description: 'The labels for the buttons.'\n      },\n      button_html: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Button HTML',\n        default: '<button class=\"jspsych-btn\">%choice%</button>',\n        array: true,\n        description: 'The html of the button. Can create own style.'\n      },\n      prompt: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Prompt',\n        default: null,\n        description: 'Any content here will be displayed under the button.'\n      },\n      stimulus_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Stimulus duration',\n        default: null,\n        description: 'How long to hide the stimulus.'\n      },\n      trial_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Trial duration',\n        default: null,\n        description: 'How long to show the trial.'\n      },\n      margin_vertical: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Margin vertical',\n        default: '0px',\n        description: 'The vertical margin of the button.'\n      },\n      margin_horizontal: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Margin horizontal',\n        default: '8px',\n        description: 'The horizontal margin of the button.'\n      },\n      response_ends_trial: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Response ends trial',\n        default: true,\n        description: 'If true, then trial will end when user responds.'\n      },\n    }\n  }\n\n  plugin.trial = function(display_element, trial) {\n\n    // display stimulus\n    var html = '<div id=\"jspsych-html-button-response-stimulus\">'+trial.stimulus+'</div>';\n\n    //display buttons\n    var buttons = [];\n    if (Array.isArray(trial.button_html)) {\n      if (trial.button_html.length == trial.choices.length) {\n        buttons = trial.button_html;\n      } else {\n        console.error('Error in html-button-response plugin. The length of the button_html array does not equal the length of the choices array');\n      }\n    } else {\n      for (var i = 0; i < trial.choices.length; i++) {\n        buttons.push(trial.button_html);\n      }\n    }\n    html += '<div id=\"jspsych-html-button-response-btngroup\">';\n    for (var i = 0; i < trial.choices.length; i++) {\n      var str = buttons[i].replace(/%choice%/g, trial.choices[i]);\n      html += '<div class=\"jspsych-html-button-response-button\" style=\"display: inline-block; margin:'+trial.margin_vertical+' '+trial.margin_horizontal+'\" id=\"jspsych-html-button-response-button-' + i +'\" data-choice=\"'+i+'\">'+str+'</div>';\n    }\n    html += '</div>';\n\n    //show prompt if there is one\n    if (trial.prompt !== null) {\n      html += trial.prompt;\n    }\n    display_element.innerHTML = html;\n\n    // start time\n    var start_time = performance.now();\n\n    // add event listeners to buttons\n    for (var i = 0; i < trial.choices.length; i++) {\n      display_element.querySelector('#jspsych-html-button-response-button-' + i).addEventListener('click', function(e){\n        var choice = e.currentTarget.getAttribute('data-choice'); // don't use dataset for jsdom compatibility\n        after_response(choice);\n      });\n    }\n\n    // store response\n    var response = {\n      rt: null,\n      button: null\n    };\n\n    // function to handle responses by the subject\n    function after_response(choice) {\n\n      // measure rt\n      var end_time = performance.now();\n      var rt = end_time - start_time;\n      response.button = choice;\n      response.rt = rt;\n\n      // after a valid response, the stimulus will have the CSS class 'responded'\n      // which can be used to provide visual feedback that a response was recorded\n      display_element.querySelector('#jspsych-html-button-response-stimulus').className += ' responded';\n\n      // disable all the buttons after a response\n      var btns = document.querySelectorAll('.jspsych-html-button-response-button button');\n      for(var i=0; i<btns.length; i++){\n        //btns[i].removeEventListener('click');\n        btns[i].setAttribute('disabled', 'disabled');\n      }\n\n      if (trial.response_ends_trial) {\n        end_trial();\n      }\n    };\n\n    // function to end trial when it is time\n    function end_trial() {\n\n      // kill any remaining setTimeout handlers\n      jsPsych.pluginAPI.clearAllTimeouts();\n\n      // gather the data to store for the trial\n      var trial_data = {\n        \"rt\": response.rt,\n        \"stimulus\": trial.stimulus,\n        \"button_pressed\": response.button\n      };\n\n      // clear the display\n      display_element.innerHTML = '';\n\n      // move on to the next trial\n      jsPsych.finishTrial(trial_data);\n    };\n\n    // hide image if timing is set\n    if (trial.stimulus_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        display_element.querySelector('#jspsych-html-button-response-stimulus').style.visibility = 'hidden';\n      }, trial.stimulus_duration);\n    }\n\n    // end trial if time limit is set\n    if (trial.trial_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        end_trial();\n      }, trial.trial_duration);\n    }\n\n  };\n\n  return plugin;\n})();\n"},739:function(n,e){n.exports="/**\n * jspsych-audio-keyboard-response\n * Josh de Leeuw\n *\n * plugin for playing an audio file and getting a keyboard response\n *\n * documentation: docs.jspsych.org\n *\n **/\n\njsPsych.plugins[\"audio-keyboard-response\"] = (function() {\n\n  var plugin = {};\n\n  jsPsych.pluginAPI.registerPreload('audio-keyboard-response', 'stimulus', 'audio');\n\n  plugin.info = {\n    name: 'audio-keyboard-response',\n    description: '',\n    parameters: {\n      stimulus: {\n        type: jsPsych.plugins.parameterType.AUDIO,\n        pretty_name: 'Stimulus',\n        default: undefined,\n        description: 'The audio to be played.'\n      },\n      choices: {\n        type: jsPsych.plugins.parameterType.KEYCODE,\n        pretty_name: 'Choices',\n        array: true,\n        default: jsPsych.ALL_KEYS,\n        description: 'The keys the subject is allowed to press to respond to the stimulus.'\n      },\n      prompt: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Prompt',\n        default: null,\n        description: 'Any content here will be displayed below the stimulus.'\n      },\n      trial_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Trial duration',\n        default: null,\n        description: 'The maximum duration to wait for a response.'\n      },\n      response_ends_trial: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Response ends trial',\n        default: true,\n        description: 'If true, the trial will end when user makes a response.'\n      },\n      trial_ends_after_audio: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Trial ends after audio',\n        default: false,\n        description: 'If true, then the trial will end as soon as the audio file finishes playing.'\n      },\n    }\n  }\n\n  plugin.trial = function(display_element, trial) {\n\n    // setup stimulus\n    var context = jsPsych.pluginAPI.audioContext();\n    if(context !== null){\n      var source = context.createBufferSource();\n      source.buffer = jsPsych.pluginAPI.getAudioBuffer(trial.stimulus);\n      source.connect(context.destination);\n    } else {\n      var audio = jsPsych.pluginAPI.getAudioBuffer(trial.stimulus);\n      audio.currentTime = 0;\n    }\n\n    // set up end event if trial needs it\n\n    if(trial.trial_ends_after_audio){\n      if(context !== null){\n        source.onended = function() {\n          end_trial();\n        }\n      } else {\n        audio.addEventListener('ended', end_trial);\n      }\n    }\n\n    // show prompt if there is one\n    if (trial.prompt !== null) {\n      display_element.innerHTML = trial.prompt;\n    }\n\n    // store response\n    var response = {\n      rt: null,\n      key: null\n    };\n\n    // function to end trial when it is time\n    function end_trial() {\n\n      // kill any remaining setTimeout handlers\n      jsPsych.pluginAPI.clearAllTimeouts();\n\n      // stop the audio file if it is playing\n      // remove end event listeners if they exist\n      if(context !== null){\n        source.stop();\n        source.onended = function() { }\n      } else {\n        audio.pause();\n        audio.removeEventListener('ended', end_trial);\n      }\n\n      // kill keyboard listeners\n      jsPsych.pluginAPI.cancelAllKeyboardResponses();\n\n      // gather the data to store for the trial\n      if(context !== null && response.rt !== null){\n        response.rt = Math.round(response.rt * 1000);\n      }\n      var trial_data = {\n        \"rt\": response.rt,\n        \"stimulus\": trial.stimulus,\n        \"key_press\": response.key\n      };\n\n      // clear the display\n      display_element.innerHTML = '';\n\n      // move on to the next trial\n      jsPsych.finishTrial(trial_data);\n    };\n\n    // function to handle responses by the subject\n    var after_response = function(info) {\n\n      // only record the first response\n      if (response.key == null) {\n        response = info;\n      }\n\n      if (trial.response_ends_trial) {\n        end_trial();\n      }\n    };\n\n    // start audio\n    if(context !== null){\n      startTime = context.currentTime;\n      source.start(startTime);\n    } else {\n      audio.play();\n    }\n\n    // start the response listener\n    if(context !== null) {\n      var keyboardListener = jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: after_response,\n        valid_responses: trial.choices,\n        rt_method: 'audio',\n        persist: false,\n        allow_held_key: false,\n        audio_context: context,\n        audio_context_start_time: startTime\n      });\n    } else {\n      var keyboardListener = jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: after_response,\n        valid_responses: trial.choices,\n        rt_method: 'performance',\n        persist: false,\n        allow_held_key: false\n      });\n    }\n\n    // end trial if time limit is set\n    if (trial.trial_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        end_trial();\n      }, trial.trial_duration);\n    }\n\n  };\n\n  return plugin;\n})();\n"},762:function(n,e){n.exports="/**\n * jspsych-survey-text\n * a jspsych plugin for free response survey questions\n *\n * Josh de Leeuw\n *\n * documentation: docs.jspsych.org\n *\n */\n\n\njsPsych.plugins['survey-text'] = (function() {\n\n  var plugin = {};\n\n  plugin.info = {\n    name: 'survey-text',\n    description: '',\n    parameters: {\n      questions: {\n        type: jsPsych.plugins.parameterType.COMPLEX,\n        array: true,\n        pretty_name: 'Questions',\n        default: undefined,\n        nested: {\n          prompt: {\n            type: jsPsych.plugins.parameterType.STRING,\n            pretty_name: 'Prompt',\n            default: undefined,\n            description: 'Prompt for the subject to response'\n          },\n          placeholder: {\n            type: jsPsych.plugins.parameterType.STRING,\n            pretty_name: 'Value',\n            default: \"\",\n            description: 'Placeholder text in the textfield.'\n          },\n          rows: {\n            type: jsPsych.plugins.parameterType.INT,\n            pretty_name: 'Rows',\n            default: 1,\n            description: 'The number of rows for the response text box.'\n          },\n          columns: {\n            type: jsPsych.plugins.parameterType.INT,\n            pretty_name: 'Columns',\n            default: 40,\n            description: 'The number of columns for the response text box.'\n          },\n          required: {\n            type: jsPsych.plugins.parameterType.BOOL,\n            pretty_name: 'Required',\n            default: false,\n            description: 'Require a response'\n          },\n          name: {\n            type: jsPsych.plugins.parameterType.STRING,\n            pretty_name: 'Question Name',\n            default: '',\n            description: 'Controls the name of data values associated with this question'\n          }\n        }\n      },\n      preamble: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Preamble',\n        default: null,\n        description: 'HTML formatted string to display at the top of the page above all the questions.'\n      },\n      button_label: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Button label',\n        default:  'Continue',\n        description: 'The text that appears on the button to finish the trial.'\n      }\n    }\n  }\n\n  plugin.trial = function(display_element, trial) {\n\n    for (var i = 0; i < trial.questions.length; i++) {\n      if (typeof trial.questions[i].rows == 'undefined') {\n        trial.questions[i].rows = 1;\n      }\n    }\n    for (var i = 0; i < trial.questions.length; i++) {\n      if (typeof trial.questions[i].columns == 'undefined') {\n        trial.questions[i].columns = 40;\n      }\n    }\n    for (var i = 0; i < trial.questions.length; i++) {\n      if (typeof trial.questions[i].value == 'undefined') {\n        trial.questions[i].value = \"\";\n      }\n    }\n\n    var html = '';\n    // show preamble text\n    if(trial.preamble !== null){\n      html += '<div id=\"jspsych-survey-text-preamble\" class=\"jspsych-survey-text-preamble\">'+trial.preamble+'</div>';\n    }\n    // start form\n    html += '<form id=\"jspsych-survey-text-form\">'\n\n    // generate question order\n    var question_order = [];\n    for(var i=0; i<trial.questions.length; i++){\n      question_order.push(i);\n    }\n    if(trial.randomize_question_order){\n      question_order = jsPsych.randomization.shuffle(question_order);\n    }\n\n    // add questions\n    for (var i = 0; i < trial.questions.length; i++) {\n      var question = trial.questions[question_order[i]];\n      var question_index = question_order[i];\n      html += '<div id=\"jspsych-survey-text-'+question_index+'\" class=\"jspsych-survey-text-question\" style=\"margin: 2em 0em;\">';\n      html += '<p class=\"jspsych-survey-text\">' + question.prompt + '</p>';\n      var autofocus = i == 0 ? \"autofocus\" : \"\";\n      var req = question.required ? \"required\" : \"\";\n      if(question.rows == 1){\n        html += '<input type=\"text\" id=\"input-'+question_index+'\"  name=\"#jspsych-survey-text-response-' + question_index + '\" data-name=\"'+question.name+'\" size=\"'+question.columns+'\" '+autofocus+' '+req+' placeholder=\"'+question.placeholder+'\"></input>';\n      } else {\n        html += '<textarea id=\"input-'+question_index+'\" name=\"#jspsych-survey-text-response-' + question_index + '\" data-name=\"'+question.name+'\" cols=\"' + question.columns + '\" rows=\"' + question.rows + '\" '+autofocus+' '+req+' placeholder=\"'+question.placeholder+'\"></textarea>';\n      }\n      html += '</div>';\n    }\n\n    // add submit button\n    html += '<input type=\"submit\" id=\"jspsych-survey-text-next\" class=\"jspsych-btn jspsych-survey-text\" value=\"'+trial.button_label+'\"></input>';\n\n    html += '</form>'\n    display_element.innerHTML = html;\n\n    // backup in case autofocus doesn't work\n    display_element.querySelector('#input-'+question_order[0]).focus();\n\n    display_element.querySelector('#jspsych-survey-text-form').addEventListener('submit', function(e) {\n      e.preventDefault();\n      // measure response time\n      var endTime = performance.now();\n      var response_time = endTime - startTime;\n\n      // create object to hold responses\n      var question_data = {};\n      \n      for(var index=0; index < trial.questions.length; index++){\n        var id = \"Q\" + index;\n        var q_element = document.querySelector('#jspsych-survey-text-'+index).querySelector('textarea, input'); \n        var val = q_element.value;\n        var name = q_element.attributes['data-name'].value;\n        if(name == ''){\n          name = id;\n        }        \n        var obje = {};\n        obje[name] = val;\n        Object.assign(question_data, obje);\n      }\n      // save data\n      var trialdata = {\n        \"rt\": response_time,\n        \"responses\": JSON.stringify(question_data)\n      };\n\n      display_element.innerHTML = '';\n\n      // next trial\n      jsPsych.finishTrial(trialdata);\n    });\n\n    var startTime = performance.now();\n  };\n\n  return plugin;\n})();\n"},763:function(n,e){n.exports="/**\n * jspsych-html-slider-response\n * a jspsych plugin for free response survey questions\n *\n * Josh de Leeuw\n *\n * documentation: docs.jspsych.org\n *\n */\n\n\njsPsych.plugins['html-slider-response'] = (function() {\n\n  var plugin = {};\n\n  plugin.info = {\n    name: 'html-slider-response',\n    description: '',\n    parameters: {\n      stimulus: {\n        type: jsPsych.plugins.parameterType.HTML_STRING,\n        pretty_name: 'Stimulus',\n        default: undefined,\n        description: 'The HTML string to be displayed'\n      },\n      min: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Min slider',\n        default: 0,\n        description: 'Sets the minimum value of the slider.'\n      },\n      max: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Max slider',\n        default: 100,\n        description: 'Sets the maximum value of the slider',\n      },\n      start: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Slider starting value',\n        default: 50,\n        description: 'Sets the starting value of the slider',\n      },\n      step: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Step',\n        default: 1,\n        description: 'Sets the step of the slider'\n      },\n      labels: {\n        type: jsPsych.plugins.parameterType.HTML_STRING,\n        pretty_name:'Labels',\n        default: [],\n        array: true,\n        description: 'Labels of the slider.',\n      },\n      slider_width: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name:'Slider width',\n        default: null,\n        description: 'Width of the slider in pixels.'\n      },\n      button_label: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Button label',\n        default:  'Continue',\n        array: false,\n        description: 'Label of the button to advance.'\n      },\n      require_movement: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Require movement',\n        default: false,\n        description: 'If true, the participant will have to move the slider before continuing.'\n      },\n      prompt: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Prompt',\n        default: null,\n        description: 'Any content here will be displayed below the slider.'\n      },\n      stimulus_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Stimulus duration',\n        default: null,\n        description: 'How long to hide the stimulus.'\n      },\n      trial_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Trial duration',\n        default: null,\n        description: 'How long to show the trial.'\n      },\n      response_ends_trial: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Response ends trial',\n        default: true,\n        description: 'If true, trial will end when user makes a response.'\n      },\n    }\n  }\n\n  plugin.trial = function(display_element, trial) {\n\n    var html = '<div id=\"jspsych-html-slider-response-wrapper\" style=\"margin: 100px 0px;\">';\n    html += '<div id=\"jspsych-html-slider-response-stimulus\">' + trial.stimulus + '</div>';\n    html += '<div class=\"jspsych-html-slider-response-container\" style=\"position:relative; margin: 0 auto 3em auto; ';\n    if(trial.slider_width !== null){\n      html += 'width:'+trial.slider_width+'px;';\n    }\n    html += '\">';\n    html += '<input type=\"range\" value=\"'+trial.start+'\" min=\"'+trial.min+'\" max=\"'+trial.max+'\" step=\"'+trial.step+'\" style=\"width: 100%;\" id=\"jspsych-html-slider-response-response\"></input>';\n    html += '<div>'\n    for(var j=0; j < trial.labels.length; j++){\n      var width = 100/(trial.labels.length-1);\n      var left_offset = (j * (100 /(trial.labels.length - 1))) - (width/2);\n      html += '<div style=\"display: inline-block; position: absolute; left:'+left_offset+'%; text-align: center; width: '+width+'%;\">';\n      html += '<span style=\"text-align: center; font-size: 80%;\">'+trial.labels[j]+'</span>';\n      html += '</div>'\n    }\n    html += '</div>';\n    html += '</div>';\n    html += '</div>';\n\n    if (trial.prompt !== null){\n      html += trial.prompt;\n    }\n\n    // add submit button\n    html += '<button id=\"jspsych-html-slider-response-next\" class=\"jspsych-btn\" '+ (trial.require_movement ? \"disabled\" : \"\") + '>'+trial.button_label+'</button>';\n\n    display_element.innerHTML = html;\n\n    var response = {\n      rt: null,\n      response: null\n    };\n    \n    if(trial.require_movement){\n      display_element.querySelector('#jspsych-html-slider-response-response').addEventListener('change', function(){\n        display_element.querySelector('#jspsych-html-slider-response-next').disabled = false;\n      })\n    }\n\n    display_element.querySelector('#jspsych-html-slider-response-next').addEventListener('click', function() {\n      // measure response time\n      var endTime = performance.now();\n      response.rt = endTime - startTime;\n      response.response = display_element.querySelector('#jspsych-html-slider-response-response').value;\n\n      if(trial.response_ends_trial){\n        end_trial();\n      } else {\n        display_element.querySelector('#jspsych-html-slider-response-next').disabled = true;\n      }\n\n    });\n\n    function end_trial(){\n\n      jsPsych.pluginAPI.clearAllTimeouts();\n\n      // save data\n      var trialdata = {\n        \"rt\": response.rt,\n        \"response\": response.response,\n        \"stimulus\": trial.stimulus\n      };\n\n      display_element.innerHTML = '';\n\n      // next trial\n      jsPsych.finishTrial(trialdata);\n    }\n\n    if (trial.stimulus_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        display_element.querySelector('#jspsych-html-slider-response-stimulus').style.visibility = 'hidden';\n      }, trial.stimulus_duration);\n    }\n\n    // end trial if trial_duration is set\n    if (trial.trial_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        end_trial();\n      }, trial.trial_duration);\n    }\n\n    var startTime = performance.now();\n  };\n\n  return plugin;\n})();\n"},764:function(n,e){n.exports="/**\n * jspsych-survey-multi-select\n * a jspsych plugin for multiple choice survey questions\n *\n * documentation: docs.jspsych.org\n *\n */\n\n\njsPsych.plugins['survey-multi-select'] = (function() {\n  var plugin = {};\n\n  plugin.info = {\n    name: 'survey-multi-select',\n    description: '',\n    parameters: {\n      questions: {\n        type: jsPsych.plugins.parameterType.COMPLEX,\n        array: true,\n        pretty_name: 'Questions',\n        nested: {\n          prompt: {\n            type: jsPsych.plugins.parameterType.STRING,\n            pretty_name: 'Prompt',\n            default: undefined,\n            description: 'The strings that will be associated with a group of options.'\n          },\n          options: {\n            type: jsPsych.plugins.parameterType.STRING,\n            pretty_name: 'Options',\n            array: true,\n            default: undefined,\n            description: 'Displays options for an individual question.'\n          },\n          horizontal: {\n            type: jsPsych.plugins.parameterType.BOOL,\n            pretty_name: 'Horizontal',\n            default: false,\n            description: 'If true, then questions are centered and options are displayed horizontally.'\n          },\n          required: {\n            type: jsPsych.plugins.parameterType.BOOL,\n            pretty_name: 'Required',\n            default: false,\n            description: 'Subject will be required to pick at least one option for this question.'\n          },\n          name: {\n            type: jsPsych.plugins.parameterType.STRING,\n            pretty_name: 'Question Name',\n            default: '',\n            description: 'Controls the name of data values associated with this question'\n          }\n        }\n      },\n      randomize_question_order: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Randomize Question Order',\n        default: false,\n        description: 'If true, the order of the questions will be randomized'\n      },\n      preamble: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Preamble',\n        default: null,\n        description: 'HTML formatted string to display at the top of the page above all the questions.'\n      },\n      button_label: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Button label',\n        default:  'Continue',\n        description: 'Label of the button.'\n      },\n      required_message: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Required message',\n        default: 'You must choose at least one response for this question',\n        description: 'Message that will be displayed if required question is not answered.'\n      }\n    }\n  }\n  plugin.trial = function(display_element, trial) {\n    var plugin_id_name = \"jspsych-survey-multi-select\";\n    var plugin_id_selector = '#' + plugin_id_name;\n    var _join = function( /*args*/ ) {\n      var arr = Array.prototype.slice.call(arguments, _join.length);\n      return arr.join(separator = '-');\n    }\n\n    // inject CSS for trial\n    var cssstr = \".jspsych-survey-multi-select-question { margin-top: 2em; margin-bottom: 2em; text-align: left; }\"+\n      \".jspsych-survey-multi-select-text span.required {color: darkred;}\"+\n      \".jspsych-survey-multi-select-horizontal .jspsych-survey-multi-select-text {  text-align: center;}\"+\n      \".jspsych-survey-multi-select-option { line-height: 2; }\"+\n      \".jspsych-survey-multi-select-horizontal .jspsych-survey-multi-select-option {  display: inline-block;  margin-left: 1em;  margin-right: 1em;  vertical-align: top;}\"+\n      \"label.jspsych-survey-multi-select-text input[type='checkbox'] {margin-right: 1em;}\"\n    display_element.innerHTML = '<style id=\"jspsych-survey-multi-select-css\">' + cssstr + '</style>';\n    \n    // form element\n    var trial_form_id = _join(plugin_id_name, \"form\");\n    display_element.innerHTML += '<form id=\"'+trial_form_id+'\"></form>';\n    var trial_form = display_element.querySelector(\"#\" + trial_form_id);\n    // show preamble text\n    var preamble_id_name = _join(plugin_id_name, 'preamble');\n    if(trial.preamble !== null){\n      trial_form.innerHTML += '<div id=\"'+preamble_id_name+'\" class=\"'+preamble_id_name+'\">'+trial.preamble+'</div>';\n    }\n    // generate question order. this is randomized here as opposed to randomizing the order of trial.questions\n    // so that the data are always associated with the same question regardless of order\n    var question_order = [];\n    for(var i=0; i<trial.questions.length; i++){\n      question_order.push(i);\n    }\n    if(trial.randomize_question_order){\n      question_order = jsPsych.randomization.shuffle(question_order);\n    }\n    // add multiple-select questions\n    for (var i = 0; i < trial.questions.length; i++) {\n      var question = trial.questions[question_order[i]];\n      var question_id = question_order[i];\n      // create question container\n      var question_classes = [_join(plugin_id_name, 'question')];\n      if (question.horizontal) {\n        question_classes.push(_join(plugin_id_name, 'horizontal'));\n      }\n\n      trial_form.innerHTML += '<div id=\"'+_join(plugin_id_name, question_id)+'\" data-name=\"'+question.name+'\" class=\"'+question_classes.join(' ')+'\"></div>';\n\n      var question_selector = _join(plugin_id_selector, question_id);\n\n      // add question text\n      display_element.querySelector(question_selector).innerHTML += '<p id=\"survey-question\" class=\"' + plugin_id_name + '-text survey-multi-select\">' + question.prompt + '</p>';\n\n      // create option check boxes\n      for (var j = 0; j < question.options.length; j++) {\n        var option_id_name = _join(plugin_id_name, \"option\", question_id, j);\n\n        // add check box container\n        display_element.querySelector(question_selector).innerHTML += '<div id=\"'+option_id_name+'\" class=\"'+_join(plugin_id_name, 'option')+'\"></div>';\n\n        // add label and question text\n        var form = document.getElementById(option_id_name)\n        var input_name = _join(plugin_id_name, 'response', question_id);\n        var input_id = _join(plugin_id_name, 'response', question_id, j);\n        var label = document.createElement('label');\n        label.setAttribute('class', plugin_id_name+'-text');\n        label.innerHTML = question.options[j];\n        label.setAttribute('for', input_id)\n\n        // create  checkboxes\n        var input = document.createElement('input');\n        input.setAttribute('type', \"checkbox\");\n        input.setAttribute('name', input_name);\n        input.setAttribute('id', input_id);\n        input.setAttribute('value', question.options[j])\n        form.appendChild(label)\n        form.insertBefore(input, label)\n      }\n    }\n    // add submit button\n    trial_form.innerHTML += '<div class=\"fail-message\"></div>'\n    trial_form.innerHTML += '<button id=\"'+plugin_id_name+'-next\" class=\"'+plugin_id_name+' jspsych-btn\">'+trial.button_label+'</button>';\n\n    // validation check on the data first for custom validation handling\n    // then submit the form\n    display_element.querySelector('#jspsych-survey-multi-select-next').addEventListener('click', function(){\n      for(var i=0; i<trial.questions.length; i++){\n        if(trial.questions[i].required){\n          if(display_element.querySelector('#jspsych-survey-multi-select-'+i+' input:checked') == null){\n            display_element.querySelector('#jspsych-survey-multi-select-'+i+' input').setCustomValidity(trial.required_message);\n          } else {\n            display_element.querySelector('#jspsych-survey-multi-select-'+i+' input').setCustomValidity('');\n          }\n        }\n      }\n      trial_form.reportValidity();\n    })\n\n    trial_form.addEventListener('submit', function(event) {\n      event.preventDefault();\n      // measure response time\n      var endTime = performance.now();\n      var response_time = endTime - startTime;\n\n      // create object to hold responses\n      var question_data = {};\n      var has_response = [];\n      for(var index=0; index<trial.questions.length; index++){\n        var match = display_element.querySelector('#jspsych-survey-multi-select-'+index);\n        var val = [];\n        var inputboxes = match.querySelectorAll(\"input[type=checkbox]:checked\")\n        for(var j=0; j<inputboxes.length; j++){\n          currentChecked = inputboxes[j];\n          val.push(currentChecked.value)\n        }\n        var id = 'Q' + index\n        var obje = {};\n        var name = id;\n        if(match.attributes['data-name'].value !== ''){\n          name = match.attributes['data-name'].value;\n        }\n        obje[name] = val;\n        Object.assign(question_data, obje);\n        if(val.length == 0){ has_response.push(false); } else { has_response.push(true); }\n      }\n\n      // save data\n      var trial_data = {\n        \"rt\": response_time,\n        \"responses\": JSON.stringify(question_data),\n        \"question_order\": JSON.stringify(question_order)\n      };\n      display_element.innerHTML = '';\n\n      // next trial\n      jsPsych.finishTrial(trial_data);\n      \n    });\n\n    var startTime = performance.now();\n  };\n\n  return plugin;\n})();\n"},765:function(n,e){n.exports="/**\n * jspsych-html-keyboard-response\n * Josh de Leeuw\n *\n * plugin for displaying a stimulus and getting a keyboard response\n *\n * documentation: docs.jspsych.org\n *\n **/\n\n\njsPsych.plugins[\"html-keyboard-response\"] = (function() {\n\n  var plugin = {};\n\n  plugin.info = {\n    name: 'html-keyboard-response',\n    description: '',\n    parameters: {\n      stimulus: {\n        type: jsPsych.plugins.parameterType.HTML_STRING,\n        pretty_name: 'Stimulus',\n        default: undefined,\n        description: 'The HTML string to be displayed'\n      },\n      choices: {\n        type: jsPsych.plugins.parameterType.KEYCODE,\n        array: true,\n        pretty_name: 'Choices',\n        default: jsPsych.ALL_KEYS,\n        description: 'The keys the subject is allowed to press to respond to the stimulus.'\n      },\n      prompt: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Prompt',\n        default: null,\n        description: 'Any content here will be displayed below the stimulus.'\n      },\n      stimulus_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Stimulus duration',\n        default: null,\n        description: 'How long to hide the stimulus.'\n      },\n      trial_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Trial duration',\n        default: null,\n        description: 'How long to show trial before it ends.'\n      },\n      response_ends_trial: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Response ends trial',\n        default: true,\n        description: 'If true, trial will end when subject makes a response.'\n      },\n\n    }\n  }\n\n  plugin.trial = function(display_element, trial) {\n\n    var new_html = '<div id=\"jspsych-html-keyboard-response-stimulus\">'+trial.stimulus+'</div>';\n\n    // add prompt\n    if(trial.prompt !== null){\n      new_html += trial.prompt;\n    }\n\n    // draw\n    display_element.innerHTML = new_html;\n\n    // store response\n    var response = {\n      rt: null,\n      key: null\n    };\n\n    // function to end trial when it is time\n    var end_trial = function() {\n\n      // kill any remaining setTimeout handlers\n      jsPsych.pluginAPI.clearAllTimeouts();\n\n      // kill keyboard listeners\n      if (typeof keyboardListener !== 'undefined') {\n        jsPsych.pluginAPI.cancelKeyboardResponse(keyboardListener);\n      }\n\n      // gather the data to store for the trial\n      var trial_data = {\n        \"rt\": response.rt,\n        \"stimulus\": trial.stimulus,\n        \"key_press\": response.key\n      };\n\n      // clear the display\n      display_element.innerHTML = '';\n\n      // move on to the next trial\n      jsPsych.finishTrial(trial_data);\n    };\n\n    // function to handle responses by the subject\n    var after_response = function(info) {\n\n      // after a valid response, the stimulus will have the CSS class 'responded'\n      // which can be used to provide visual feedback that a response was recorded\n      display_element.querySelector('#jspsych-html-keyboard-response-stimulus').className += ' responded';\n\n      // only record the first response\n      if (response.key == null) {\n        response = info;\n      }\n\n      if (trial.response_ends_trial) {\n        end_trial();\n      }\n    };\n\n    // start the response listener\n    if (trial.choices != jsPsych.NO_KEYS) {\n      var keyboardListener = jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: after_response,\n        valid_responses: trial.choices,\n        rt_method: 'performance',\n        persist: false,\n        allow_held_key: false\n      });\n    }\n\n    // hide stimulus if stimulus_duration is set\n    if (trial.stimulus_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        display_element.querySelector('#jspsych-html-keyboard-response-stimulus').style.visibility = 'hidden';\n      }, trial.stimulus_duration);\n    }\n\n    // end trial if trial_duration is set\n    if (trial.trial_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        end_trial();\n      }, trial.trial_duration);\n    }\n\n  };\n\n  return plugin;\n})();\n"},784:function(n,e){n.exports="/**\n * jspsych-audio-button-response\n * Kristin Diep\n *\n * plugin for playing an audio file and getting a keyboard response\n *\n * documentation: docs.jspsych.org\n *\n **/\n\njsPsych.plugins[\"audio-button-response\"] = (function() {\n\tvar plugin = {};\n\n\tjsPsych.pluginAPI.registerPreload('audio-button-response', 'stimulus', 'audio');\n\n\tplugin.info = {\n\t\tname: 'audio-button-response',\n\t\tdescription: '',\n\t\tparameters: {\n\t\t\tstimulus: {\n\t\t\t\ttype: jsPsych.plugins.parameterType.AUDIO,\n        pretty_name: 'Stimulus',\n\t\t\t\tdefault: undefined,\n\t\t\t\tdescription: 'The audio to be played.'\n\t\t\t},\n\t\t\tchoices: {\n\t\t\t\ttype: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Choices',\n\t\t\t\tdefault: undefined,\n\t\t\t\tarray: true,\n\t\t\t\tdescription: 'The button labels.'\n\t\t\t},\n      button_html: {\n        type: jsPsych.plugins.parameterType.HTML_STRING,\n        pretty_name: 'Button HTML',\n        default: '<button class=\"jspsych-btn\">%choice%</button>',\n        array: true,\n        description: 'Custom button. Can make your own style.'\n      },\n      prompt: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Prompt',\n        default: null,\n        description: 'Any content here will be displayed below the stimulus.'\n      },\n      trial_duration: {\n        type: jsPsych.plugins.parameterType.INT,\n        pretty_name: 'Trial duration',\n        default: null,\n        description: 'The maximum duration to wait for a response.'\n      },\n      margin_vertical: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Margin vertical',\n        default: '0px',\n        description: 'Vertical margin of button.'\n      },\n      margin_horizontal: {\n        type: jsPsych.plugins.parameterType.STRING,\n        pretty_name: 'Margin horizontal',\n        default: '8px',\n        description: 'Horizontal margin of button.'\n      },\n      response_ends_trial: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Response ends trial',\n        default: true,\n        description: 'If true, the trial will end when user makes a response.'\n      },\n      trial_ends_after_audio: {\n        type: jsPsych.plugins.parameterType.BOOL,\n        pretty_name: 'Trial ends after audio',\n        default: false,\n        description: 'If true, then the trial will end as soon as the audio file finishes playing.'\n      },\n    }\n  }\n\n  plugin.trial = function(display_element, trial) {\n\n    // setup stimulus\n    var context = jsPsych.pluginAPI.audioContext();\n    if(context !== null){\n      var source = context.createBufferSource();\n      source.buffer = jsPsych.pluginAPI.getAudioBuffer(trial.stimulus);\n      source.connect(context.destination);\n    } else {\n      var audio = jsPsych.pluginAPI.getAudioBuffer(trial.stimulus);\n      audio.currentTime = 0;\n    }\n\n    // set up end event if trial needs it\n    if(trial.trial_ends_after_audio){\n      if(context !== null){\n        source.onended = function() {\n          end_trial();\n        }\n      } else {\n        audio.addEventListener('ended', end_trial);\n      }\n    }\n\n  \t//display buttons\n    var buttons = [];\n    if (Array.isArray(trial.button_html)) {\n      if (trial.button_html.length == trial.choices.length) {\n        buttons = trial.button_html;\n      } else {\n        console.error('Error in image-button-response plugin. The length of the button_html array does not equal the length of the choices array');\n      }\n    } else {\n      for (var i = 0; i < trial.choices.length; i++) {\n        buttons.push(trial.button_html);\n      }\n    }\n\n    var html = '<div id=\"jspsych-audio-button-response-btngroup\">';\n    for (var i = 0; i < trial.choices.length; i++) {\n      var str = buttons[i].replace(/%choice%/g, trial.choices[i]);\n      html += '<div class=\"jspsych-audio-button-response-button\" style=\"cursor: pointer; display: inline-block; margin:'+trial.margin_vertical+' '+trial.margin_horizontal+'\" id=\"jspsych-audio-button-response-button-' + i +'\" data-choice=\"'+i+'\">'+str+'</div>';\n    }\n\t\thtml += '</div>';\n\n\t\t//show prompt if there is one\n\t\tif (trial.prompt !== null) {\n\t\t\thtml += trial.prompt;\n\t\t}\n\n\t\tdisplay_element.innerHTML = html;\n\n\t\tfor (var i = 0; i < trial.choices.length; i++) {\n      display_element.querySelector('#jspsych-audio-button-response-button-' + i).addEventListener('click', function(e){\n        var choice = e.currentTarget.getAttribute('data-choice'); // don't use dataset for jsdom compatibility\n        after_response(choice);\n      });\n    }\n\n    // store response\n    var response = {\n      rt: null,\n      button: null\n    };\n\n    // function to handle responses by the subject\n    function after_response(choice) {\n\n      // measure rt\n      var end_time = performance.now();\n      var rt = end_time - start_time;\n      response.button = choice;\n      response.rt = rt;\n\n      // disable all the buttons after a response\n      var btns = document.querySelectorAll('.jspsych-audio-button-response-button button');\n      for(var i=0; i<btns.length; i++){\n        //btns[i].removeEventListener('click');\n        btns[i].setAttribute('disabled', 'disabled');\n      }\n\n      if (trial.response_ends_trial) {\n        end_trial();\n      }\n    };\n\n    // function to end trial when it is time\n    function end_trial() {\n\n\t\t\t// stop the audio file if it is playing\n\t\t\t// remove end event listeners if they exist\n\t\t\tif(context !== null){\n\t\t\t\tsource.stop();\n\t\t\t\tsource.onended = function() { }\n\t\t\t} else {\n\t\t\t\taudio.pause();\n\t\t\t\taudio.removeEventListener('ended', end_trial);\n\t\t\t}\n\n      // kill any remaining setTimeout handlers\n      jsPsych.pluginAPI.clearAllTimeouts();\n\n      // gather the data to store for the trial\n      var trial_data = {\n        \"rt\": response.rt,\n        \"stimulus\": trial.stimulus,\n        \"button_pressed\": response.button\n      };\n\n      // clear the display\n      display_element.innerHTML = '';\n\n      // move on to the next trial\n      jsPsych.finishTrial(trial_data);\n    };\n\n\t\t// start time\n    var start_time = performance.now();\n\n\t\t// start audio\n    if(context !== null){\n      startTime = context.currentTime;\n      source.start(startTime);\n    } else {\n      audio.play();\n    }\n\n    // end trial if time limit is set\n    if (trial.trial_duration !== null) {\n      jsPsych.pluginAPI.setTimeout(function() {\n        end_trial();\n      }, trial.trial_duration);\n    }\n\n  };\n\n  return plugin;\n})();\n"}}]);